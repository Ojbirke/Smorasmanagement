{% extends 'base.html' %}
{% load i18n %}

{% block title %}{% translate "Match Manager" %}: {{ match_session.name }}{% endblock %}

{% block extra_head %}
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
    /* Mobile optimizations */
    body {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        overscroll-behavior: none;
    }
    
    .pitch-container {
        background-color: #3B7A12;
        border-radius: 8px;
        position: relative;
        margin-bottom: 1rem;
        height: 220px;
        overflow: hidden;
    }
    
    .pitch-markings {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 8px;
    }
    
    .center-circle {
        position: absolute;
        width: 60px;
        height: 60px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
    }
    
    .center-mark {
        position: absolute;
        width: 6px;
        height: 6px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: 50%;
    }
    
    .centerline {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        background-color: rgba(255, 255, 255, 0.5);
    }
    
    .player-on-pitch {
        position: absolute;
        width: 50px;
        height: 50px;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background-color: var(--bs-primary);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 0.8rem;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        z-index: 1;
        transition: transform 0.2s ease;
    }
    
    .player-on-pitch:active {
        transform: translate(-50%, -50%) scale(1.1);
    }
    
    .player-minutes {
        position: absolute;
        bottom: 2px;
        right: 2px;
        font-size: 0.6rem;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        border-radius: 10px;
        padding: 1px 4px;
    }
    
    .player-bench-card {
        transition: transform 0.2s ease;
    }
    
    .player-bench-card:active {
        transform: scale(1.05);
    }
    
    .bench-container {
        max-height: 35vh;
        overflow-y: auto;
    }
    
    .timer-container {
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    /* Custom toggle switch for active/inactive */
    .custom-switch {
        display: inline-block;
        height: 24px;
        position: relative;
        width: 48px;
    }
    
    .custom-switch input {
        display: none;
    }
    
    .slider {
        background-color: #ccc;
        bottom: 0;
        cursor: pointer;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
        transition: .4s;
        border-radius: 24px;
    }
    
    .slider:before {
        background-color: white;
        bottom: 4px;
        content: "";
        height: 16px;
        left: 4px;
        position: absolute;
        transition: .4s;
        width: 16px;
        border-radius: 50%;
    }
    
    input:checked + .slider {
        background-color: #198754;
    }
    
    input:checked + .slider:before {
        transform: translateX(24px);
    }
    
    /* Sub recommendation badge */
    .sub-recommend {
        position: absolute;
        top: -5px;
        right: -5px;
        width: 20px;
        height: 20px;
        background-color: #dc3545;
        border-radius: 50%;
        color: white;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.2);
            opacity: 0.8;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    /* Animation for critical countdown */
    .animate-pulse {
        animation: pulse 1s infinite;
    }
    
    /* Custom bottom action bar */
    .action-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: white;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 1000;
    }
    
    /* Adjust content so it's not hidden behind the action bar */
    .content-padding-bottom {
        padding-bottom: 70px;
    }
    
    /* Mobile-specific size adjustments */
    @media (max-width: 576px) {
        .player-on-pitch {
            width: 45px;
            height: 45px;
            font-size: 0.7rem;
        }
        
        .pitch-container {
            height: 180px;
        }
        
        h1 {
            font-size: 1.5rem;
        }
        
        h2 {
            font-size: 1.3rem;
        }
        
        .center-circle {
            width: 40px;
            height: 40px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-3 content-padding-bottom">
    <!-- Header with match info and status -->
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h1 class="h4 mb-0">{{ match_session.name }}</h1>
        
        <div class="d-flex align-items-center">
            {% if can_edit %}
                {% if match_session.is_active %}
                    <a href="{% url 'match-session-stop' match_session.id %}" class="btn btn-sm btn-danger me-2">
                        <i class="bi bi-stop-circle"></i> {% translate "Stop" %}
                    </a>
                    <div class="btn-group me-2">
                        <button type="button" class="btn btn-sm btn-outline-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi bi-gear"></i> {% translate "Match Controls" %}
                        </button>
                        <ul class="dropdown-menu">
                            <li><button class="dropdown-item reset-sub-timer-btn" data-session-id="{{ match_session.id }}">
                                <i class="bi bi-arrow-repeat"></i> {% translate "Reset Substitution Timer" %}
                            </button></li>
                            <li><button class="dropdown-item reset-match-time-btn" data-session-id="{{ match_session.id }}">
                                <i class="bi bi-arrow-counterclockwise"></i> {% translate "Reset Period Time" %}
                            </button></li>
                            {% if match_session.current_period < match_session.periods %}
                            <li><hr class="dropdown-divider"></li>
                            <li><button class="dropdown-item set-period-btn" data-session-id="{{ match_session.id }}" data-period="2">
                                <i class="bi bi-2-circle"></i> {% translate "Set to Period 2" %}
                            </button></li>
                            {% endif %}
                        </ul>
                    </div>
                {% else %}
                    <a href="{% url 'match-session-start' match_session.id %}" class="btn btn-sm btn-success me-2">
                        <i class="bi bi-play-circle"></i> {% translate "Start" %}
                    </a>
                {% endif %}
            {% endif %}
            
            <a href="{% url 'match-session-detail' match_session.id %}" class="btn btn-sm btn-outline-secondary">
                <i class="bi bi-arrow-left"></i> {% translate "Back" %}
            </a>
        </div>
    </div>
    
    <!-- Match timer and period info -->
    <div class="timer-container mb-3">
        <div class="row align-items-center">
            <div class="col-6">
                <div class="fs-5">
                    {% if match_session.is_active %}
                        <span class="badge bg-success me-1">{% translate "ACTIVE" %}</span>
                        <span class="fw-bold">{{ current_game_time }}:00</span>
                    {% else %}
                        <span class="badge bg-secondary me-1">{% translate "INACTIVE" %}</span>
                        <span class="fw-bold">00:00</span>
                    {% endif %}
                    <span class="badge {% if match_session.current_period > 1 %}bg-info{% else %}bg-primary{% endif %} ms-2">{% translate "Period" %} {{ current_period }}/{{ total_periods|default:2 }}</span>
                </div>
                <div>
                    {% if minutes_remaining is not None %}
                        <span class="text-muted">{{ minutes_remaining }} min left in period</span>
                    {% endif %}
                    <span class="badge {% if match_session.current_period > 1 %}bg-info{% else %}bg-secondary{% endif %} ms-2">
                        {% if match_session.current_period > 1 %}
                            Previous periods: {{ elapsed_minutes_previous_periods }} min
                        {% else %}
                            {% translate "First period" %}
                        {% endif %}
                    </span>
                </div>
            </div>
            
            <div class="col-6 text-end">
                <div class="small">
                    {% if match_session.is_active and next_sub_countdown is not None %}
                        {% if next_sub_countdown.critical %}
                            <span class="badge bg-danger animate-pulse" style="font-size: 1.1em;">
                                <i class="bi bi-clock"></i> {% translate "Next sub:" %} {{ next_sub_countdown.value }} {% translate next_sub_countdown.unit %}
                            </span>
                        {% else %}
                            <span class="badge bg-primary">
                                <i class="bi bi-clock"></i> {% translate "Next sub:" %} {{ next_sub_countdown.value }} {% translate next_sub_countdown.unit %}
                            </span>
                        {% endif %}
                    {% else %}
                        <span class="text-muted">{% translate "Manual substitutions only" %}</span>
                    {% endif %}
                </div>
                
                {% if match_session.is_active and is_coach_or_admin %}
                <div class="mt-2">
                    <button id="resetSubTimerBtn" class="btn btn-sm btn-outline-primary">
                        <i class="bi bi-clock-history"></i> {% translate "Reset Sub Timer" %}
                    </button>
                </div>
                {% endif %}
            </div>
        </div>
        
        {% if match_session.is_active and is_coach_or_admin %}
        <div class="row mt-2">
            <div class="col-12">
                <div class="btn-group w-100" role="group" aria-label="Match Controls">
                    <button id="resetMatchTimeBtn" class="btn btn-outline-danger">
                        <i class="bi bi-arrow-clockwise"></i> {% translate "Reset Match Time" %}
                    </button>
                    
                    {% if current_period == 1 and total_periods > 1 %}
                    <button id="setPeriod2Btn" class="btn btn-outline-info">
                        <i class="bi bi-2-circle"></i> {% translate "Set to Period 2" %}
                    </button>
                    {% endif %}
                </div>
            </div>
        </div>
        {% endif %}
    </div>
    
    <!-- Football pitch visualization -->
    <div class="pitch-container">
        <div class="pitch-markings"></div>
        <div class="centerline"></div>
        <div class="center-circle"></div>
        <div class="center-mark"></div>
        
        <!-- Players on pitch -->
        {% for player in on_pitch %}
            <div class="player-on-pitch" id="player-{{ player.player.id }}" 
                 style="top: 50%; left: {% widthratio forloop.counter on_pitch.count|add:1 100 %}%;"
                 data-player-id="{{ player.player.id }}"
                 data-player-name="{{ player.player.first_name }}">
                {{ player.player.first_name }}
                <span class="player-minutes">{{ player.minutes_played }}m</span>
                
                {% if player.minutes_played < 10 %}
                    <span class="sub-recommend">!</span>
                {% endif %}
            </div>
        {% endfor %}
    </div>
    
    <!-- Controls for player rotation -->
    <div class="card shadow-sm mb-3">
        <div class="card-header bg-primary text-white">
            <h2 class="h5 mb-0">{% translate "On Pitch" %} ({{ on_pitch.count }})</h2>
        </div>
        <div class="card-body p-0">
            <div class="list-group list-group-flush">
                {% for player in on_pitch %}
                    <div class="list-group-item d-flex justify-content-between align-items-center">
                        <div>
                            <span class="fw-bold">{{ player.player.first_name }}</span>
                            <small class="d-block text-muted">
                                <span id="pitch-time-{{ player.player.id }}">{{ player.minutes_played }}</span> {% translate "minutes played" %}
                                <span class="badge bg-success">{% translate "on pitch" %}</span>
                            </small>
                        </div>
                        
                        {% if match_session.is_active and can_edit and on_bench.count > 0 %}
                            <div class="dropdown">
                                <button class="btn btn-sm btn-outline-primary dropdown-toggle" 
                                       type="button" data-bs-toggle="dropdown">
                                    {% translate "Sub Out" %}
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end">
                                    {% for bench_player in on_bench %}
                                        <li>
                                            <a class="dropdown-item quick-sub-link" 
                                               href="#" 
                                               data-player-in="{{ bench_player.player.id }}" 
                                               data-player-out="{{ player.player.id }}"
                                               data-session="{{ match_session.id }}">
                                                {{ bench_player.player.first_name }} ({{ bench_player.minutes_played }}m)
                                            </a>
                                        </li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                    </div>
                {% empty %}
                    <div class="list-group-item text-center">{% translate "No players on pitch" %}</div>
                {% endfor %}
            </div>
        </div>
    </div>
    
    <!-- Bench players -->
    <div class="card shadow-sm mb-3">
        <div class="card-header bg-secondary text-white">
            <h2 class="h5 mb-0">{% translate "Bench" %} ({{ on_bench.count }})</h2>
        </div>
        <div class="card-body p-0 bench-container">
            <div class="list-group list-group-flush">
                {% for player in on_bench %}
                    <div class="list-group-item d-flex justify-content-between align-items-center player-bench-card">
                        <div>
                            <span class="fw-bold">{{ player.player.first_name }}</span>
                            <small class="d-block text-muted">
                                <span id="bench-time-{{ player.player.id }}">{{ player.minutes_played }}</span> {% translate "minutes played" %}
                                <span class="badge bg-secondary">{% translate "on bench" %}</span>
                            </small>
                        </div>
                        
                        {% if match_session.is_active and can_edit and on_pitch.count > 0 %}
                            <div class="dropdown">
                                <button class="btn btn-sm btn-outline-success dropdown-toggle" 
                                       type="button" data-bs-toggle="dropdown">
                                    {% translate "Sub In" %}
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end">
                                    {% for pitch_player in on_pitch %}
                                        <li>
                                            <a class="dropdown-item quick-sub-link" 
                                               href="#" 
                                               data-player-in="{{ player.player.id }}" 
                                               data-player-out="{{ pitch_player.player.id }}"
                                               data-session="{{ match_session.id }}">
                                                For {{ pitch_player.player.first_name }} ({{ pitch_player.minutes_played }}m)
                                            </a>
                                        </li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                    </div>
                {% empty %}
                    <div class="list-group-item text-center">{% translate "No players on bench" %}</div>
                {% endfor %}
            </div>
        </div>
    </div>
</div>

<!-- Fixed action bar at the bottom -->
<div class="action-bar">
    <div>
        <span class="fw-bold">{% translate "Players" %}:</span> 
        <span class="badge bg-primary">{{ on_pitch.count }}</span> {% translate "on" %} / 
        <span class="badge bg-secondary">{{ on_bench.count }}</span> {% translate "bench" %}
    </div>
    
    <div>
        {% if match_session.is_active %}
            <button id="recommendSubBtn" class="btn btn-success me-2">
                <i class="bi bi-lightbulb"></i> {% translate "Recommend Subs" %}
            </button>
            <a href="{% url 'substitution-create' match_session.id %}" class="btn btn-primary">
                <i class="bi bi-arrow-left-right"></i> {% translate "Manual Sub" %}
            </a>
        {% else %}
            <a href="{% url 'match-session-players' match_session.id %}" class="btn btn-primary">
                <i class="bi bi-people"></i> {% translate "Edit Players" %}
            </a>
        {% endif %}
    </div>
</div>

<!-- Modal for confirming substitution -->
<div class="modal fade" id="subConfirmModal" tabindex="-1" aria-labelledby="subConfirmModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="subConfirmModalLabel">{% translate "Confirm Substitution" %}</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="subConfirmBody">
                {% translate "Are you sure you want to make this substitution?" %}
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{% translate "Cancel" %}</button>
                <button type="button" class="btn btn-primary" id="confirmSubBtn">{% translate "Confirm" %}</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal for auto-sub recommendation -->
<div class="modal fade" id="autoSubModal" tabindex="-1" aria-labelledby="autoSubModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="autoSubModalLabel">{% translate "Recommended Substitutions" %}</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-3">{% translate "Based on playing time, we recommend these substitutions:" %}</p>
                
                <div id="autoSubSuggestions" class="list-group">
                    <!-- Will be filled dynamically -->
                </div>
                <div class="d-none" id="bulkActionsContainer">
                    <hr>
                    <div class="d-flex justify-content-end mt-3">
                        <button id="applySelectedSubsBtn" class="btn btn-success">
                            <i class="bi bi-check2-all"></i> {% translate "Apply Selected Substitutions" %}
                        </button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{% translate "Close" %}</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal for substitution result -->
<div class="modal fade" id="subResultModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">{% translate "Substitution Made" %}</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="subResultBody">
                Substitution successful!
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">{% translate "OK" %}</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Elements
        const quickSubLinks = document.querySelectorAll('.quick-sub-link');
        const subConfirmModal = document.getElementById('subConfirmModal');
        
        // Function to handle multiple substitutions at once
        function applyMultipleSubstitutions(substitutions) {
            if (!substitutions || substitutions.length === 0) return;
            
            // Create a summary of what will be done
            let confirmMessage = '<p>Are you sure you want to make these substitutions?</p><div class="mt-3">';
            
            substitutions.forEach((sub, index) => {
                confirmMessage += `
                    <div class="d-flex align-items-center mb-3 ${index < substitutions.length - 1 ? 'border-bottom pb-2' : ''}">
                        <div class="text-center">
                            <span class="fw-bold">${index + 1}.</span>
                        </div>
                        <div class="d-flex align-items-center flex-grow-1 mx-3">
                            <div class="text-center me-2">
                                <div class="badge bg-secondary p-2">${sub.playerOutName}</div>
                                <div class="small">OUT</div>
                            </div>
                            <div class="mx-2"><i class="bi bi-arrow-left-right"></i></div>
                            <div class="text-center ms-2">
                                <div class="badge bg-success p-2">${sub.playerInName}</div>
                                <div class="small">IN</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            confirmMessage += '</div>';
            
            // Show the confirmation modal
            subConfirmBody.innerHTML = confirmMessage;
            
            // Set up the confirmation button to process all substitutions
            const confirmHandler = function() {
                // Remove the event listener to prevent multiple calls
                confirmSubBtn.removeEventListener('click', confirmHandler);
                
                // Hide the modal
                bsSubConfirmModal.hide();
                
                // Process each substitution sequentially with Promises
                let promise = Promise.resolve();
                let results = [];
                
                substitutions.forEach(sub => {
                    promise = promise.then(() => {
                        return fetch(`/team/match-sessions/${sub.sessionId}/quick-sub/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Requested-With': 'XMLHttpRequest',
                                'X-CSRFToken': getCookie('csrftoken')
                            },
                            body: JSON.stringify({
                                player_in: sub.playerIn,
                                player_out: sub.playerOut
                            })
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                results.push({
                                    success: true,
                                    playerIn: data.player_in,
                                    playerOut: data.player_out,
                                    minute: data.minute,
                                    period: data.period
                                });
                                
                                // Update the UI immediately for each successful substitution
                                // Using data from response, not sub object for accurate names
                                updatePlayerPositionsAfterSubstitution(
                                    data.player_in_id || sub.playerIn, // Fallback to sub.playerIn if ID not in response
                                    data.player_out_id || sub.playerOut,
                                    { first_name: data.player_in },
                                    { first_name: data.player_out }
                                );
                                
                                console.log("Applied substitution:", {
                                    in_id: data.player_in_id || sub.playerIn,
                                    in_name: data.player_in,
                                    out_id: data.player_out_id || sub.playerOut,
                                    out_name: data.player_out
                                });
                            } else {
                                results.push({
                                    success: false,
                                    error: data.error || 'Unknown error',
                                    playerInName: sub.playerInName,
                                    playerOutName: sub.playerOutName
                                });
                            }
                            return results;
                        });
                    });
                });
                
                // After all substitutions are processed
                promise.then(allResults => {
                    // Show results summary
                    let resultMessage = '<div class="alert alert-success mb-3"><strong>Multiple substitutions completed</strong></div>';
                    
                    // Count successes and failures
                    const successes = results.filter(r => r.success).length;
                    
                    resultMessage += `<p>${successes} of ${results.length} substitutions were successful.</p><div class="mt-3">`;
                    
                    // List all substitutions with success/failure status
                    results.forEach((result, index) => {
                        if (result.success) {
                            resultMessage += `
                                <div class="d-flex align-items-center mb-2 ${index < results.length - 1 ? 'border-bottom pb-2' : ''}">
                                    <div class="text-success me-2"><i class="bi bi-check-circle-fill"></i></div>
                                    <div>${result.playerIn} replaced ${result.playerOut} at ${result.minute}' in period ${result.period}</div>
                                </div>
                            `;
                        } else {
                            resultMessage += `
                                <div class="d-flex align-items-center mb-2 ${index < results.length - 1 ? 'border-bottom pb-2' : ''}">
                                    <div class="text-danger me-2"><i class="bi bi-x-circle-fill"></i></div>
                                    <div>Failed to substitute ${result.playerInName} for ${result.playerOutName}: ${result.error}</div>
                                </div>
                            `;
                        }
                    });
                    
                    resultMessage += '</div>';
                    
                    // Display results in the result modal
                    subResultBody.innerHTML = resultMessage;
                    bsSubResultModal.show();
                    
                    // Update the UI without page reload after multiple substitutions
                    subResultModal.addEventListener('hidden.bs.modal', function () {
                        // Force a comprehensive UI update
                        updatePlayingTimes();
                        
                        // Refresh the player counts
                        const pitchCount = document.querySelector('.action-bar .badge.bg-primary');
                        const benchCount = document.querySelector('.action-bar .badge.bg-secondary');
                        
                        if (pitchCount && benchCount) {
                            // Re-count actual players in each list
                            const onPitchList = document.querySelector('.card-header.bg-primary + .card-body .list-group');
                            const onBenchList = document.querySelector('.card-header.bg-secondary + .card-body .list-group');
                            
                            if (onPitchList && onBenchList) {
                                const pitchItems = onPitchList.querySelectorAll('.list-group-item');
                                const benchItems = onBenchList.querySelectorAll('.list-group-item');
                                
                                pitchCount.textContent = pitchItems.length;
                                benchCount.textContent = benchItems.length;
                            }
                        }
                    }, { once: true });
                })
                .catch(error => {
                    console.error('Error processing substitutions:', error);
                    subResultBody.innerHTML = `
                        <div class="alert alert-danger">
                            <p class="mb-0"><strong>Error:</strong> An error occurred while processing the substitutions.</p>
                        </div>
                    `;
                    bsSubResultModal.show();
                });
            };
            
            // Add event listener for confirmation
            confirmSubBtn.addEventListener('click', confirmHandler);
            
            // Show the confirmation modal
            bsSubConfirmModal.show();
        }
        const subConfirmBody = document.getElementById('subConfirmBody');
        const confirmSubBtn = document.getElementById('confirmSubBtn');
        const recommendSubBtn = document.getElementById('recommendSubBtn');
        const autoSubModal = document.getElementById('autoSubModal');
        const autoSubSuggestions = document.getElementById('autoSubSuggestions');
        const subResultModal = document.getElementById('subResultModal');
        const subResultBody = document.getElementById('subResultBody');
        
        // Bootstrap modals
        const bsSubConfirmModal = new bootstrap.Modal(subConfirmModal);
        const bsAutoSubModal = new bootstrap.Modal(autoSubModal);
        const bsSubResultModal = new bootstrap.Modal(subResultModal);
        
        // Substitution data
        let currentSubData = null;
        
        // Handle quick sub links
        quickSubLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                
                const playerIn = this.dataset.playerIn;
                const playerOut = this.dataset.playerOut;
                const sessionId = this.dataset.session;
                
                // Get player names
                const playerInName = this.textContent.trim().split('(')[0].trim();
                const playerOutName = this.closest('.dropdown').previousElementSibling.querySelector('.fw-bold').textContent.trim();
                
                // Set confirmation message
                subConfirmBody.innerHTML = `
                    <p>Are you sure you want to make this substitution?</p>
                    <div class="d-flex align-items-center justify-content-center my-3">
                        <div class="text-center me-3">
                            <div class="badge bg-secondary p-2 mb-2">${playerOutName}</div>
                            <div><i class="bi bi-arrow-right fs-3"></i></div>
                            <div class="small">OUT</div>
                        </div>
                        <div class="fs-3 mx-3"><i class="bi bi-arrow-left-right"></i></div>
                        <div class="text-center ms-3">
                            <div class="badge bg-success p-2 mb-2">${playerInName}</div>
                            <div><i class="bi bi-arrow-left fs-3"></i></div>
                            <div class="small">IN</div>
                        </div>
                    </div>
                `;
                
                // Store data for confirmation
                currentSubData = {
                    playerIn,
                    playerOut,
                    sessionId
                };
                
                // Show confirmation modal
                bsSubConfirmModal.show();
            });
        });
        
        // Handle confirmation button click
        confirmSubBtn.addEventListener('click', function() {
            if (!currentSubData) return;
            
            // Hide confirmation modal
            bsSubConfirmModal.hide();
            
            // Send AJAX request to make the substitution
            fetch(`/team/match-sessions/${currentSubData.sessionId}/quick-sub/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    player_in: currentSubData.playerIn,
                    player_out: currentSubData.playerOut
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    subResultBody.innerHTML = `
                        <div class="alert alert-success">
                            <p class="mb-1"><strong>Substitution successful!</strong></p>
                            <p class="mb-0">
                                <span class="fw-bold">${data.player_in}</span> has replaced 
                                <span class="fw-bold">${data.player_out}</span> 
                                at ${data.minute}' in period ${data.period}.
                            </p>
                        </div>
                    `;
                    bsSubResultModal.show();
                    
                    // Update the UI without page reload after substitution
                    subResultModal.addEventListener('hidden.bs.modal', function () {
                        updatePlayingTimes();
                        
                        // Update player positions on pitch
                        updatePlayerPositionsAfterSubstitution(
                            currentSubData.playerIn, 
                            currentSubData.playerOut, 
                            {first_name: data.player_in}, 
                            {first_name: data.player_out}
                        );
                    }, { once: true });
                } else {
                    subResultBody.innerHTML = `
                        <div class="alert alert-danger">
                            <p class="mb-0"><strong>Error:</strong> ${data.error}</p>
                        </div>
                    `;
                    bsSubResultModal.show();
                }
            })
            .catch(error => {
                console.error('Error:', error);
                subResultBody.innerHTML = `
                    <div class="alert alert-danger">
                        <p class="mb-0"><strong>Error:</strong> An error occurred while making the substitution.</p>
                    </div>
                `;
                bsSubResultModal.show();
            });
        });
        
        // Auto-substitution functionality has been disabled as requested by the user
        // The auto-sub button has been removed from the UI and the automatic substitution
        // logic has been commented out. All substitutions are now manual only.
        
        // Handle recommendation button click
        if (recommendSubBtn) {
            recommendSubBtn.addEventListener('click', function() {
                // Clear previous recommendations
                autoSubSuggestions.innerHTML = '';
                
                // Show loading state
                autoSubSuggestions.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"></div><p class="mt-2">Loading recommendations...</p></div>';
                
                // Show modal while loading
                bsAutoSubModal.show();
                
                // Get recommendations
                const matchSessionId = {{ match_session.id }};
                fetch('/team/match-sessions/' + matchSessionId + '/recommendations/', {
                    method: 'GET',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRFToken': getCookie('csrftoken')
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Clear loading indicator
                        autoSubSuggestions.innerHTML = '';
                        
                        if (data.recommendations.length === 0) {
                            // No recommendations
                            autoSubSuggestions.innerHTML = '<div class="alert alert-info">No recommendations available at this time. This could be because all players have similar playing times or there are not enough players on the bench.</div>';
                        } else {
                            // Build recommendations UI
                            data.recommendations.forEach((rec, index) => {
                                const recItem = document.createElement('div');
                                recItem.className = 'list-group-item';
                                
                                // Create recommendation list item with checkbox and dropdown
                                recItem.innerHTML = `
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <div class="form-check form-check-inline me-2">
                                            <input class="form-check-input rec-checkbox" type="checkbox" 
                                                id="rec-check-${index}" 
                                                data-player-out="${rec.player_out_id}"
                                                data-player-out-name="${rec.player_out_name}"
                                                data-session="{{ match_session.id }}">
                                        </div>
                                        <div class="d-flex align-items-center flex-grow-1">
                                            <div class="text-center me-3">
                                                <div class="badge bg-secondary p-2 mb-2">${rec.player_out_name}</div>
                                                <div class="small text-muted">${rec.player_out_minutes} mins played</div>
                                            </div>
                                            <div class="fs-4 mx-3"><i class="bi bi-arrow-left-right"></i></div>
                                            <div class="ms-3">
                                                <select class="form-select form-select-sm bench-player-select" 
                                                    data-rec-index="${index}">
                                                    <option value="">Select bench player</option>
                                                </select>
                                                <div class="mt-1 text-muted bench-player-stats-${index}">
                                                    <!-- Will be populated when player is selected -->
                                                </div>
                                            </div>
                                        </div>
                                        <button class="btn btn-sm btn-primary apply-rec-btn" 
                                            data-player-out="${rec.player_out_id}"
                                            data-session="{{ match_session.id }}">
                                            Apply
                                        </button>
                                    </div>
                                    <div class="small text-muted recommendation-reason-${index}">${rec.reason}</div>
                                `;
                                
                                autoSubSuggestions.appendChild(recItem);
                            });
                            
                            // Show the bulk actions container
                            document.getElementById('bulkActionsContainer').classList.remove('d-none');
                            
                            // First populate bench player dropdowns for each recommendation
                            data.players_on_bench.forEach(benchPlayer => {
                                document.querySelectorAll('.bench-player-select').forEach(select => {
                                    const option = document.createElement('option');
                                    option.value = benchPlayer.id;
                                    option.textContent = benchPlayer.name;
                                    option.dataset.minutes = benchPlayer.minutes;
                                    option.dataset.benchMinutes = benchPlayer.bench_minutes || 0;
                                    select.appendChild(option);
                                });
                            });
                            
                            // Add change event listeners to bench player dropdowns
                            document.querySelectorAll('.bench-player-select').forEach(select => {
                                select.addEventListener('change', function() {
                                    const recIndex = this.dataset.recIndex;
                                    const playerId = this.value;
                                    
                                    if (!playerId) {
                                        // Clear stats and return if no player selected
                                        document.querySelector(`.bench-player-stats-${recIndex}`).innerHTML = '';
                                        return;
                                    }
                                    
                                    // Find player data
                                    const selectedOption = this.options[this.selectedIndex];
                                    const minutes = selectedOption.dataset.minutes;
                                    const benchMinutes = selectedOption.dataset.benchMinutes;
                                    const playerName = selectedOption.textContent;
                                    
                                    // Update stats display
                                    document.querySelector(`.bench-player-stats-${recIndex}`).innerHTML = `
                                        <div class="badge bg-success p-2 mb-1">${playerName}</div>
                                        <div>${minutes} mins played</div>
                                        ${benchMinutes > 0 ? `<div class="text-info">${benchMinutes} mins on bench</div>` : ''}
                                    `;
                                    
                                    // Update Apply button with the new player info
                                    const applyBtn = select.closest('.list-group-item').querySelector('.apply-rec-btn');
                                    applyBtn.dataset.playerIn = playerId;
                                    applyBtn.dataset.playerInName = playerName;
                                    
                                    // Update checkbox with player data
                                    const checkbox = select.closest('.list-group-item').querySelector('.rec-checkbox');
                                    checkbox.dataset.playerIn = playerId;
                                    checkbox.dataset.playerInName = playerName;
                                });
                            });
                            
                            // Add event listeners to checkboxes
                            document.querySelectorAll('.rec-checkbox').forEach(checkbox => {
                                checkbox.addEventListener('change', function() {
                                    // Check if any checkboxes are selected
                                    const anyChecked = document.querySelectorAll('.rec-checkbox:checked').length > 0;
                                    // Show/hide apply button based on selection
                                    document.getElementById('applySelectedSubsBtn').classList.toggle('d-none', !anyChecked);
                                });
                            });
                            
                            // Add event listener to the apply selected button
                            document.getElementById('applySelectedSubsBtn').addEventListener('click', function() {
                                const checkedBoxes = document.querySelectorAll('.rec-checkbox:checked');
                                if (checkedBoxes.length === 0) return;
                                
                                // Check if all selected recommendations have bench players selected
                                let allValid = true;
                                checkedBoxes.forEach(checkbox => {
                                    const listItem = checkbox.closest('.list-group-item');
                                    const select = listItem.querySelector('.bench-player-select');
                                    if (!select.value) {
                                        allValid = false;
                                    }
                                });
                                
                                if (!allValid) {
                                    alert('Please select bench players for all checked substitutions');
                                    return;
                                }
                                
                                // Close recommendation modal
                                bsAutoSubModal.hide();
                                
                                // Prepare substitutions data
                                const substitutions = Array.from(checkedBoxes).map(checkbox => {
                                    const listItem = checkbox.closest('.list-group-item');
                                    const select = listItem.querySelector('.bench-player-select');
                                    const playerIn = select.value;
                                    const playerInName = select.options[select.selectedIndex].textContent;
                                    
                                    return {
                                        playerIn: playerIn,
                                        playerOut: checkbox.dataset.playerOut,
                                        playerInName: playerInName,
                                        playerOutName: checkbox.dataset.playerOutName,
                                        sessionId: checkbox.dataset.session
                                    };
                                });
                                
                                // Apply substitutions one by one
                                applyMultipleSubstitutions(substitutions);
                            });
                            
                            // Add event listeners to the Apply buttons
                            document.querySelectorAll('.apply-rec-btn').forEach(btn => {
                                btn.addEventListener('click', function() {
                                    // Get selected bench player from dropdown
                                    const listItem = this.closest('.list-group-item');
                                    const select = listItem.querySelector('.bench-player-select');
                                    const playerIn = select.value;
                                    
                                    if (!playerIn) {
                                        alert('Please select a bench player first');
                                        return;
                                    }
                                    
                                    const playerOut = this.dataset.playerOut;
                                    const sessionId = this.dataset.session;
                                    const playerInName = select.options[select.selectedIndex].textContent;
                                    
                                    // Close recommendation modal
                                    bsAutoSubModal.hide();
                                    
                                    // Get player out name from the element
                                    const playerOutName = this.closest('.list-group-item').querySelector('.badge.bg-secondary').textContent.trim();
                                    
                                    // Set up confirmation modal
                                    subConfirmBody.innerHTML = `
                                        <p>Are you sure you want to make this substitution?</p>
                                        <div class="d-flex align-items-center justify-content-center my-3">
                                            <div class="text-center me-3">
                                                <div class="badge bg-secondary p-2 mb-2">${playerOutName}</div>
                                                <div><i class="bi bi-arrow-right fs-3"></i></div>
                                                <div class="small">OUT</div>
                                            </div>
                                            <div class="fs-3 mx-3"><i class="bi bi-arrow-left-right"></i></div>
                                            <div class="text-center ms-3">
                                                <div class="badge bg-success p-2 mb-2">${playerInName}</div>
                                                <div><i class="bi bi-arrow-left fs-3"></i></div>
                                                <div class="small">IN</div>
                                            </div>
                                        </div>
                                    `;
                                    
                                    // Store data for confirmation
                                    currentSubData = {
                                        playerIn,
                                        playerOut,
                                        sessionId
                                    };
                                    
                                    // Show confirmation modal
                                    bsSubConfirmModal.show();
                                });
                            });
                        }
                    } else {
                        // Error fetching recommendations
                        autoSubSuggestions.innerHTML = `<div class="alert alert-danger">Error getting recommendations: ${data.error || 'Unknown error'}</div>`;
                    }
                })
                .catch(error => {
                    console.error('Error getting recommendations:', error);
                    autoSubSuggestions.innerHTML = '<div class="alert alert-danger">Error communicating with the server. Please try again.</div>';
                });
            });
        }
        
        // Function to get CSRF token from cookies
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        // Auto-update playing times
        {% if match_session.is_active %}
        let updateTimerInterval;
        let clockInterval;
        let currentGameTime = {{ current_game_time|default:0 }};
        let matchStartTime = {% if match_session.start_time %}new Date("{{ match_session.start_time|date:'c' }}"){% else %}null{% endif %};
        // Initialize elapsed seconds from previous periods (time accumulated before current session start)
        let elapsedSecondsPreviousPeriods = {{ elapsed_seconds_previous_periods|default:0 }};
        let clientSideClockRunning = matchStartTime !== null;
        let currentPeriod = {{ current_period|default:1 }};
        // Define matchSessionId for use in API calls
        const matchSessionId = {{ match_session.id }};
        let criticalCountdown = false;
        let criticalTimerInterval = null;
        
        function startAutoRefresh() {
            // First immediate update
            updatePlayingTimes();
            
            // Then set interval for more frequent updates (every 5 seconds)
            updateTimerInterval = setInterval(updatePlayingTimes, 5000);
            
            // Start the clock that updates every second
            startClock();
        }
        
        function startClock() {
            // Clear existing interval if there is one
            if (clockInterval) {
                clearInterval(clockInterval);
            }
            
            // Set up the clock to update every second
            clockInterval = setInterval(updateClock, 1000);
        }
        
        function updateClock() {
            if (!matchStartTime) return;
            
            // Calculate current match time in seconds
            const now = new Date();
            // Calculate elapsed seconds for the current session (since the match was last started)
            const elapsedSecondsCurrentSession = Math.floor((now - matchStartTime) / 1000);
            
            // Add elapsed seconds from previous periods or session stops to get total match time
            // This ensures we maintain accumulated time even when stopping/starting
            const elapsedSecondsPrevious = elapsedSecondsPreviousPeriods;
            const elapsedSeconds = elapsedSecondsCurrentSession + elapsedSecondsPrevious;
            const elapsedMinutes = Math.floor(elapsedSeconds / 60);
            const elapsedSecondsInMinute = elapsedSeconds % 60;
            
            // Store current calculated time for consistency
            globalMatchInfo.client_elapsed_seconds = elapsedSeconds;
            
            // Update the match clock
            const matchInfoEl = document.querySelector('.fs-5 .fw-bold');
            if (matchInfoEl) {
                matchInfoEl.textContent = `${elapsedMinutes}:${elapsedSecondsInMinute.toString().padStart(2, '0')}`;
            }
            
            // Real-time update for player times (on pitch)
            const playersOnPitch = document.querySelectorAll('.player-on-pitch');
            playersOnPitch.forEach(player => {
                const playerId = player.dataset.playerId;
                const minutesEl = player.querySelector('.player-minutes');
                if (minutesEl) {
                    const currentMinutes = parseInt(minutesEl.textContent);
                    // If player is on pitch, increment their time based on realtime
                    const lastUpdate = window.lastPlayerUpdate || 0;
                    const currentMinute = Math.floor(elapsedSeconds / 60);
                    // Update display if it's a new minute
                    if (currentMinute > lastUpdate) {
                        window.lastPlayerUpdate = currentMinute;
                        // Update all player times
                        updatePlayerTimes();
                    }
                }
            });
            
            // Update period if needed (only when a full minute passes)
            if (elapsedMinutes !== currentGameTime) {
                currentGameTime = elapsedMinutes;
                
                // Use the global match info object
                const newPeriod = Math.min(
                    Math.floor(elapsedMinutes / globalMatchInfo.period_length) + 1, 
                    globalMatchInfo.total_periods
                );
                
                if (newPeriod !== currentPeriod) {
                    currentPeriod = newPeriod;
                    const periodBadge = document.querySelector('.badge.bg-primary.ms-2');
                    if (periodBadge) {
                        // Fix: Pass total_periods from Django context to JavaScript properly
                        const totalPeriods = {{ total_periods|default:2 }};
                        periodBadge.textContent = `Period ${currentPeriod}/${totalPeriods}`;
                    }
                }
            }
        }
        
        // Separate function to update player times that can be called by both functions
        function updatePlayerTimes() {
            // Make sure matchSessionId is defined
            const sessionId = matchSessionId || {{ match_session.id }};
            fetch('/team/match-sessions/' + sessionId + '/update-times/', {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': getCookie('csrftoken')
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update player times on cards and bubbles
                    for (const playerId in data.playing_times) {
                        const playerData = data.playing_times[playerId];
                        
                        // Update on pitch player bubbles
                        const playerOnPitch = document.getElementById(`player-${playerId}`);
                        if (playerOnPitch) {
                            const minutesEl = playerOnPitch.querySelector('.player-minutes');
                            if (minutesEl) {
                                minutesEl.textContent = `${playerData.minutes}m`;
                            }
                        }
                        
                        // Update player list times - Using IDs for more reliable updates
                        if (playerData.on_pitch) {
                            // Update pitch player time
                            const pitchTimeEl = document.getElementById(`pitch-time-${playerId}`);
                            if (pitchTimeEl) {
                                pitchTimeEl.textContent = playerData.minutes;
                            }
                        } else {
                            // Update bench player time
                            const benchTimeEl = document.getElementById(`bench-time-${playerId}`);
                            if (benchTimeEl) {
                                benchTimeEl.textContent = playerData.minutes;
                                
                                // Find the badge element and update it to show bench time
                                const parent = benchTimeEl.closest('.text-muted');
                                if (parent) {
                                    const badge = parent.querySelector('.badge');
                                    if (badge) {
                                        badge.textContent = `${playerData.bench_minutes}m on bench`;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Update the match information
                    if (data.match_info) {
                        // Update global match info object
                        updateGlobalMatchInfo(data.match_info);
                        
                        // Only update the time display if we don't have a client-side clock running
                        // This prevents the server's elapsed time from overriding our client calculations
                        if (!matchStartTime) {
                            const timeDisplay = document.querySelector('.fs-5 .fw-bold');
                            if (timeDisplay) {
                                timeDisplay.textContent = `${data.match_info.elapsed}:00`;
                            }
                        }
                        
                        // Update period badge
                        const periodBadge = document.querySelector('.badge.bg-primary.ms-2');
                        if (periodBadge) {
                            // Access total_periods from either the data object or fall back to Django context
                            const totalPeriods = data.match_info.total_periods || {{ total_periods|default:2 }};
                            periodBadge.textContent = `Period ${data.match_info.period}/${totalPeriods}`;
                        }
                        
                        // Update minutes remaining in period
                        if (data.match_info.minute_in_period !== undefined) {
                            const periodLength = globalMatchInfo.period_length;
                            const minutesRemaining = periodLength - data.match_info.minute_in_period;
                            const minutesEl = document.querySelector('.text-muted:not(:has(.badge))');
                            if (minutesEl && minutesRemaining >= 0) {
                                minutesEl.textContent = `${minutesRemaining} min left in period`;
                            }
                        }
                        
                        // Update substitution timer
                        if (data.match_info.next_sub_countdown !== null) {
                            const countdownEl = document.querySelector('.col-6.text-end .small .badge');
                            if (countdownEl) {
                                // Check if this is a critical countdown (within 30 seconds)
                                if (data.match_info.next_sub_countdown.critical) {
                                    countdownEl.className = 'badge bg-danger animate-pulse';
                                    countdownEl.style.fontSize = '1.1em';
                                    countdownEl.innerHTML = `<i class="bi bi-clock"></i> Next sub: ${data.match_info.next_sub_countdown.value} ${data.match_info.next_sub_countdown.unit}`;
                                } else {
                                    countdownEl.className = 'badge bg-primary';
                                    countdownEl.style.fontSize = '';
                                    countdownEl.innerHTML = `<i class="bi bi-clock"></i> Next sub: ${data.match_info.next_sub_countdown.value} ${data.match_info.next_sub_countdown.unit}`;
                                }
                            }
                        }
                    }
                }
            })
            .catch(error => {
                console.error('Error updating player times:', error);
            });
        }
        
        function updatePlayingTimes() {
            // Use the updatePlayerTimes function to update player times
            updatePlayerTimes();
            
            // Additionally, update the match info
            // Make sure matchSessionId is defined
            const sessionId = matchSessionId || {{ match_session.id }};
            fetch('/team/match-sessions/' + sessionId + '/update-times/', {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': getCookie('csrftoken')
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Only update match start time if it's not already set
                    if (!matchStartTime && data.match_info.start_time) {
                        matchStartTime = new Date(data.match_info.start_time);
                        clientSideClockRunning = true;
                        startClock(); // Ensure clock is running
                    }
                    
                    // Update period info and badge
                    currentPeriod = data.match_info.period;
                    
                    // Update global match info
                    if (data.match_info) {
                        updateGlobalMatchInfo(data.match_info);
                        
                        // Update our client-side elapsed seconds from previous periods
                        // This ensures we track time properly when stopping/starting
                        if (data.match_info.elapsed_seconds_previous_periods !== undefined) {
                            elapsedSecondsPreviousPeriods = data.match_info.elapsed_seconds_previous_periods;
                        } else if (data.match_info.elapsed_time !== undefined) {
                            // Backwards compatibility with older API responses
                            elapsedSecondsPreviousPeriods = data.match_info.elapsed_time;
                        }
                    }
                    
                    // Update period badge in the header
                    const periodBadge = document.querySelector('.badge.bg-primary.ms-2');
                    if (periodBadge) {
                        // Access total_periods from either the data object or fall back to Django context
                        const totalPeriods = data.match_info.total_periods || {{ total_periods|default:2 }};
                        periodBadge.textContent = `Period ${data.match_info.period}/${totalPeriods}`;
                    }
                    
                    // Update minutes remaining in period
                    if (data.match_info.minute_in_period !== undefined) {
                        const periodLength = globalMatchInfo.period_length;
                        const minutesRemaining = periodLength - data.match_info.minute_in_period;
                        const periodInfoEl = document.querySelector('.col-6 > div:nth-child(2)');
                        if (periodInfoEl) {
                            // Create the HTML with dynamic content
                            let html = '';
                            if (minutesRemaining >= 0) {
                                html += `<span class="text-muted">${minutesRemaining} min left in period</span>`;
                            }
                            
                            // Add information about previous periods if applicable
                            if (data.match_info.period > 1) {
                                html += `<span class="badge bg-info ms-2">Previous periods: ${data.match_info.elapsed_minutes_previous_periods} min</span>`;
                            } else {
                                html += `<span class="badge bg-secondary ms-2">First period</span>`;
                            }
                            
                            periodInfoEl.innerHTML = html;
                        }
                    }
                    
                    // Update substitution countdown
                    if (data.match_info.hasOwnProperty('next_sub_countdown')) {
                        // Find the countdown element
                        const countdownEl = document.querySelector('.col-6.text-end .small');
                        if (countdownEl) {
                            if (data.match_info.next_sub_countdown !== null) {
                                // Check if this is a critical countdown (within 30 seconds)
                                if (data.match_info.next_sub_countdown.critical) {
                                    countdownEl.innerHTML = `<span class="badge bg-danger animate-pulse" style="font-size: 1.1em;">
                                        <i class="bi bi-clock"></i> Next sub: ${data.match_info.next_sub_countdown.value} ${data.match_info.next_sub_countdown.unit}
                                    </span>`;
                                    
                                    // If this is the first time we've seen a critical countdown, 
                                    // set up faster updates (every second)
                                    if (!criticalCountdown) {
                                        criticalCountdown = true;
                                        console.log('Critical countdown detected, switching to 1-second updates');
                                        
                                        // Clear existing interval and set up a faster one
                                        if (criticalTimerInterval) clearInterval(criticalTimerInterval);
                                        criticalTimerInterval = setInterval(updatePlayingTimes, 1000);
                                    }
                                } else {
                                    countdownEl.innerHTML = `<span class="badge bg-primary">
                                        <i class="bi bi-clock"></i> Next sub: ${data.match_info.next_sub_countdown.value} ${data.match_info.next_sub_countdown.unit}
                                    </span>`;
                                    
                                    // If we were in critical mode but now we're not, disable fast updates
                                    if (criticalCountdown) {
                                        criticalCountdown = false;
                                        console.log('Critical countdown ended, switching back to normal updates');
                                        
                                        // Clear the fast interval
                                        if (criticalTimerInterval) {
                                            clearInterval(criticalTimerInterval);
                                            criticalTimerInterval = null;
                                        }
                                    }
                                }
                            } else {
                                countdownEl.innerHTML = `<span class="text-muted">Manual substitutions only</span>`;
                            }
                        }
                    }
                }
            })
            .catch(error => {
                console.error('Error updating match time info:', error);
            });
        }
        
        /**
         * Updates player positions after a substitution without reloading the page
         * @param {number} playerInId - ID of the player being subbed in
         * @param {number} playerOutId - ID of the player being subbed out
         * @param {object} playerInData - Data about the player being subbed in
         * @param {object} playerOutData - Data about the player being subbed out
         */
        function updatePlayerPositionsAfterSubstitution(playerInId, playerOutId, playerInData, playerOutData) {
            console.log("Updating player positions after substitution:", 
                        {playerInId, playerOutId, playerInData, playerOutData});
            
            // 1. Remove the player being substituted out from the pitch
            const playerOutElement = document.getElementById(`player-${playerOutId}`);
            if (playerOutElement) {
                // Save position for the new player
                const position = {
                    top: playerOutElement.style.top,
                    left: playerOutElement.style.left
                };
                
                // Remove from pitch
                playerOutElement.remove();
                
                // 2. Create a new element for the player coming in
                const pitchContainer = document.querySelector('.pitch-container');
                const newPlayerElement = document.createElement('div');
                newPlayerElement.id = `player-${playerInId}`;
                newPlayerElement.className = 'player-on-pitch';
                newPlayerElement.style.top = position.top;
                newPlayerElement.style.left = position.left;
                newPlayerElement.dataset.playerId = playerInId;
                newPlayerElement.dataset.playerName = playerInData.first_name;
                
                // Add player name and minutes played
                newPlayerElement.innerHTML = `
                    ${playerInData.first_name}
                    <span class="player-minutes">0m</span>
                `;
                
                // Add the new player to the pitch
                pitchContainer.appendChild(newPlayerElement);
            }
            
            // 3. Update the bench and pitch lists
            // This could be done by moving elements or preferably by just updating the text
            
            // Find and update the player lists
            const onPitchList = document.querySelector('.card-header.bg-primary + .card-body .list-group');
            const onBenchList = document.querySelector('.card-header.bg-secondary + .card-body .list-group');
            
            if (onPitchList && onBenchList) {
                // Find player elements in lists
                const pitchItems = onPitchList.querySelectorAll('.list-group-item');
                const benchItems = onBenchList.querySelectorAll('.list-group-item');
                
                // Look for player out in pitch list to move to bench
                for (const item of pitchItems) {
                    if (item.textContent.includes(playerOutData.first_name)) {
                        const playerInfo = item.querySelector('.fw-bold');
                        const playerStatus = item.querySelector('.badge');
                        
                        if (playerStatus) {
                            playerStatus.className = 'badge bg-secondary';
                            playerStatus.textContent = 'on bench';
                        }
                        
                        // Move to bench list if possible
                        if (onBenchList) {
                            onBenchList.appendChild(item);
                        }
                        break;
                    }
                }
                
                // Look for player in in bench list to move to pitch
                for (const item of benchItems) {
                    if (item.textContent.includes(playerInData.first_name)) {
                        const playerInfo = item.querySelector('.fw-bold');
                        const playerStatus = item.querySelector('.badge');
                        
                        if (playerStatus) {
                            playerStatus.className = 'badge bg-success';
                            playerStatus.textContent = 'on pitch';
                        }
                        
                        // Move to pitch list if possible
                        if (onPitchList) {
                            onPitchList.appendChild(item);
                        }
                        break;
                    }
                }
            }
            
            // 4. Update the counts in the action bar
            const pitchCount = document.querySelector('.action-bar .badge.bg-primary');
            const benchCount = document.querySelector('.action-bar .badge.bg-secondary');
            
            if (pitchCount && benchCount && onPitchList && onBenchList) {
                // Recalculate accurate player counts
                const pitchItems = onPitchList.querySelectorAll('.list-group-item');
                const benchItems = onBenchList.querySelectorAll('.list-group-item');
                
                // Update counts based on actual DOM elements
                pitchCount.textContent = pitchItems.length;
                benchCount.textContent = benchItems.length;
                
                console.log("Updated player counts - On pitch:", pitchItems.length, "On bench:", benchItems.length);
            }
        }
        
        // Global variables to store match info for all functions to use
        let globalMatchInfo = {
            period: {{ current_period|default:1 }},
            total_periods: {{ match_session.periods }},
            period_length: {{ period_length|default:25 }},
            elapsed_seconds: {{ elapsed_seconds_previous_periods|default:0 }} // From previous periods
        };
        
        // Function to update global match info from AJAX response
        function updateGlobalMatchInfo(matchInfo) {
            if (matchInfo) {
                globalMatchInfo = {
                    ...globalMatchInfo,
                    ...matchInfo
                };
            }
        }
        
        // Event handlers for match control buttons
        const resetSubTimerBtn = document.getElementById('resetSubTimerBtn');
        const resetMatchTimeBtn = document.getElementById('resetMatchTimeBtn');
        const setPeriod2Btn = document.getElementById('setPeriod2Btn');
        
        if (resetSubTimerBtn) {
            resetSubTimerBtn.addEventListener('click', function() {
                if (confirm('{% translate "Are you sure you want to reset the substitution timer?" %}')) {
                    fetch('/team/match-sessions/' + matchSessionId + '/reset-sub-timer/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': getCookie('csrftoken'),
                            'Content-Type': 'application/json'
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Reset the substitution timer in the UI
                            const countdownEl = document.querySelector('.col-6.text-end .small');
                            if (countdownEl) {
                                countdownEl.innerHTML = `<span class="badge bg-primary">
                                    <i class="bi bi-clock"></i> {% translate "Next sub:" %} ${data.substitution_reset ? "0 min" : "calculating"}
                                </span>`;
                            }
                            
                            // Make sure to clear any critical countdown state
                            if (criticalTimerInterval) {
                                clearInterval(criticalTimerInterval);
                                criticalTimerInterval = null;
                                criticalCountdown = false;
                                
                                // Reset to normal update interval
                                if (updateTimerInterval) clearInterval(updateTimerInterval);
                                updateTimerInterval = setInterval(updatePlayingTimes, 5000);
                            }
                            
                            // Flash success message
                            const button = this;
                            button.classList.add('btn-success');
                            button.classList.remove('btn-outline-primary');
                            button.innerHTML = '<i class="bi bi-check-circle"></i> {% translate "Reset Complete" %}';
                            
                            // Update the UI immediately with fresh data
                            updatePlayingTimes();
                            
                            // Reset the button after a delay
                            setTimeout(() => {
                                button.classList.remove('btn-success');
                                button.classList.add('btn-outline-primary');
                                button.innerHTML = '<i class="bi bi-clock-history"></i> {% translate "Reset Sub Timer" %}';
                            }, 2000);
                        } else {
                            alert('{% translate "Error resetting substitution timer:" %} ' + (data.error || '{% translate "Unknown error" %}'));
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('{% translate "Error resetting substitution timer. Please try again." %}');
                    });
                }
            });
        }
        
        if (resetMatchTimeBtn) {
            resetMatchTimeBtn.addEventListener('click', function() {
                if (confirm('{% translate "Are you sure you want to reset the match time to the start of the current period? This cannot be undone." %}')) {
                    fetch('/team/match-sessions/' + matchSessionId + '/reset-match-time/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': getCookie('csrftoken'),
                            'Content-Type': 'application/json'
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Reset the client-side start time
                            matchStartTime = new Date();
                            
                            // Reset the display timer to 0
                            const matchInfoEl = document.querySelector('.fs-5 .fw-bold');
                            if (matchInfoEl) {
                                matchInfoEl.textContent = '0:00';
                            }
                            
                            // Immediately update playing times to reflect reset
                            // This will clear the criticalCountdown state if needed
                            if (criticalTimerInterval) {
                                clearInterval(criticalTimerInterval);
                                criticalTimerInterval = null;
                                criticalCountdown = false;
                            }
                            
                            // Flash success message
                            const button = this;
                            button.classList.add('btn-success');
                            button.classList.remove('btn-outline-danger');
                            button.innerHTML = '<i class="bi bi-check-circle"></i> {% translate "Reset Complete" %}';
                            
                            // Update the UI immediately with a direct call to API
                            updatePlayingTimes();
                            
                            // Reset the button after a delay
                            setTimeout(() => {
                                button.classList.remove('btn-success');
                                button.classList.add('btn-outline-danger');
                                button.innerHTML = '<i class="bi bi-arrow-clockwise"></i> {% translate "Reset Match Time" %}';
                            }, 2000);
                        } else {
                            alert('{% translate "Error resetting match time:" %} ' + (data.error || '{% translate "Unknown error" %}'));
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('{% translate "Error resetting match time. Please try again." %}');
                    });
                }
            });
        }
        
        if (setPeriod2Btn) {
            setPeriod2Btn.addEventListener('click', function() {
                if (confirm('{% translate "Are you sure you want to set the current period to Period 2? This will adjust the match time accordingly." %}')) {
                    fetch('/team/match-sessions/' + matchSessionId + '/set-period/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': getCookie('csrftoken'),
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ period: 2 })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Update global match info
                            globalMatchInfo.current_period = data.current_period;
                            globalMatchInfo.elapsed_seconds = data.elapsed_time;
                            
                            // Reset the client-side start time to now
                            matchStartTime = new Date(data.start_time);
                            
                            // Reset the display timer for the new period
                            const matchInfoEl = document.querySelector('.fs-5 .fw-bold');
                            if (matchInfoEl) {
                                matchInfoEl.textContent = `0:00`;
                            }
                            
                            // Make sure to update the period badge
                            const periodBadge = document.querySelector('.badge.bg-primary.ms-2');
                            if (periodBadge) {
                                periodBadge.textContent = `{% translate "Period" %} ${data.current_period}/${globalMatchInfo.total_periods}`;
                                // Update class for the badge - change from primary to info for period 2+
                                if (data.current_period > 1) {
                                    periodBadge.classList.remove('bg-primary');
                                    periodBadge.classList.add('bg-info');
                                }
                            }
                            
                            // Reset any critical countdown state
                            if (criticalTimerInterval) {
                                clearInterval(criticalTimerInterval);
                                criticalTimerInterval = null;
                                criticalCountdown = false;
                            }
                            
                            // Hide the Period 2 button
                            this.style.display = 'none';
                            
                            // Update the UI immediately
                            updatePlayingTimes();
                            
                            // Show success message
                            alert('{% translate "Successfully changed to Period 2" %}');
                        } else {
                            alert('{% translate "Error setting period:" %} ' + (data.error || '{% translate "Unknown error" %}'));
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('{% translate "Error setting period. Please try again." %}');
                    });
                }
            });
        }
        
        // Start auto-refresh when page loads
        startAutoRefresh();
        
        // Clean up when page is unloaded
        window.addEventListener('beforeunload', function() {
            if (updateTimerInterval) {
                clearInterval(updateTimerInterval);
            }
            if (clockInterval) {
                clearInterval(clockInterval);
            }
            if (criticalTimerInterval) {
                clearInterval(criticalTimerInterval);
            }
        });
        {% endif %}
        
        // Players dragging on pitch (simple implementation)
        const playersOnPitch = document.querySelectorAll('.player-on-pitch');
        const pitchContainer = document.querySelector('.pitch-container');
        
        if (pitchContainer && playersOnPitch.length > 0) {
            // Just for visualization, actual positions not saved in this basic implementation
            playersOnPitch.forEach(player => {
                let isDragging = false;
                let startX, startY;
                let originalLeft, originalTop;
                
                // Touch events for mobile
                player.addEventListener('touchstart', function(e) {
                    isDragging = true;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    originalLeft = parseInt(player.style.left);
                    originalTop = parseInt(player.style.top);
                    player.style.zIndex = 10;
                    e.preventDefault();
                });
                
                document.addEventListener('touchmove', function(e) {
                    if (!isDragging) return;
                    
                    const pitchRect = pitchContainer.getBoundingClientRect();
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    
                    // Calculate new position as percentage
                    let newLeft = originalLeft + ((touchX - startX) / pitchRect.width * 100);
                    let newTop = originalTop + ((touchY - startY) / pitchRect.height * 100);
                    
                    // Constrain to pitch
                    newLeft = Math.max(5, Math.min(95, newLeft));
                    newTop = Math.max(5, Math.min(95, newTop));
                    
                    player.style.left = `${newLeft}%`;
                    player.style.top = `${newTop}%`;
                    e.preventDefault();
                });
                
                document.addEventListener('touchend', function(e) {
                    if (!isDragging) return;
                    isDragging = false;
                    player.style.zIndex = 1;
                });
                
                // Mouse events for desktop/testing
                player.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    originalLeft = parseInt(player.style.left);
                    originalTop = parseInt(player.style.top);
                    player.style.zIndex = 10;
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    
                    const pitchRect = pitchContainer.getBoundingClientRect();
                    
                    // Calculate new position as percentage
                    let newLeft = originalLeft + ((e.clientX - startX) / pitchRect.width * 100);
                    let newTop = originalTop + ((e.clientY - startY) / pitchRect.height * 100);
                    
                    // Constrain to pitch
                    newLeft = Math.max(5, Math.min(95, newLeft));
                    newTop = Math.max(5, Math.min(95, newTop));
                    
                    player.style.left = `${newLeft}%`;
                    player.style.top = `${newTop}%`;
                });
                
                document.addEventListener('mouseup', function(e) {
                    if (!isDragging) return;
                    isDragging = false;
                    player.style.zIndex = 1;
                });
            });
        }
    });
</script>
{% endblock %}