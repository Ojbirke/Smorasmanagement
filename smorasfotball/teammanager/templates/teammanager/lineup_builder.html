{% extends 'base.html' %}
{% load static %}

{% block title %}Lineup Builder | Smørås G2015 Fotball{% endblock %}

{% block extra_css %}
<style>
    #pitch-container {
        position: relative;
        width: 100%;
        background-color: #4CAF50;
        border: 2px solid white;
        border-radius: 5px;
        padding-top: 56.25%; /* 16:9 Aspect Ratio */
        overflow: hidden;
    }
    
    #pitch {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    
    .pitch-marking {
        stroke: rgba(255, 255, 255, 0.8);
        stroke-width: 2px;
        fill: none;
    }
    
    .player-item {
        position: absolute;
        width: 60px;
        height: 60px;
        margin-left: -30px;
        margin-top: -30px;
        text-align: center;
        font-size: 0.8rem;
        cursor: move;
        z-index: 10;
        touch-action: none;
        user-select: none;
    }
    
    .player-circle {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: #0066cc;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        font-weight: bold;
        position: relative;
    }
    
    .player-circle.starter {
        background-color: #0066cc;
    }
    
    .player-circle.substitute {
        background-color: #6699cc;
    }
    
    .player-jersey {
        font-size: 1.2rem;
        font-weight: bold;
    }
    
    .player-name {
        width: 100%;
        text-align: center;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border-radius: 10px;
        padding: 2px 5px;
        margin-top: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .player-position {
        position: absolute;
        bottom: -15px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.7rem;
        background-color: black;
        color: white;
        border-radius: 8px;
        padding: 1px 4px;
    }
    
    .player-bank {
        border: 2px dashed #aaa;
        border-radius: 5px;
        min-height: 150px;
        padding: 10px;
        background-color: #f7f7f7;
    }
    
    .player-bank .player-item {
        position: relative;
        display: inline-block;
        margin: 5px;
        vertical-align: top;
    }
    
    .remove-player {
        position: absolute;
        top: -5px;
        right: -5px;
        background-color: red;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 0.7rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 20;
    }
    
    #position-editor {
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #f8f9fa;
        margin-bottom: 15px;
    }
    
    .controls-container {
        position: sticky;
        top: 80px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <!-- Hidden form with CSRF token for JavaScript use -->
    <form id="csrf-form" style="display: none;">
        {% csrf_token %}
    </form>
    
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h1>
            Lineup Builder: {{ lineup.name }}
            {% if lineup.match %}
                <small class="text-muted d-block fs-5">{{ lineup.match }} ({{ lineup.match.date|date:"M d, Y" }})</small>
            {% endif %}
        </h1>
        
        <div class="btn-group">
            <a href="{% url 'lineup-list' %}" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left"></i> Back to Lineups
            </a>
            <a href="{% url 'lineup-add' %}" class="btn btn-success">
                <i class="fas fa-plus"></i> New Lineup
            </a>
            <a href="{% url 'lineup-edit' lineup.id %}" class="btn btn-outline-primary">
                <i class="fas fa-pencil-alt"></i> Edit Details
            </a>
            <a href="{% url 'lineup-export-pdf' lineup.id %}" class="btn btn-outline-success">
                <i class="fas fa-file-pdf"></i> Export PDF
            </a>
        </div>
    </div>
    
    <div class="row">
        <div class="col-lg-8">
            <!-- Pitch Container -->
            <div id="pitch-container">
                <svg id="pitch" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
                    <!-- Field Background -->
                    <rect width="100" height="100" fill="#4CAF50" />
                    
                    <!-- Field Markings -->
                    <!-- Outer Boundary -->
                    <rect x="5" y="5" width="90" height="90" class="pitch-marking" />
                    
                    <!-- Center Line -->
                    <line x1="50" y1="5" x2="50" y2="95" class="pitch-marking" />
                    
                    <!-- Center Circle -->
                    <circle cx="50" cy="50" r="9.15" class="pitch-marking" />
                    
                    <!-- Center Spot -->
                    <circle cx="50" cy="50" r="0.5" class="pitch-marking" fill="white" />
                    
                    <!-- Goal Areas (6-yard boxes) -->
                    <rect x="5" y="36" width="5" height="28" class="pitch-marking" />
                    <rect x="90" y="36" width="5" height="28" class="pitch-marking" />
                    
                    <!-- Penalty Areas (18-yard boxes) -->
                    <rect x="5" y="25" width="16" height="50" class="pitch-marking" />
                    <rect x="79" y="25" width="16" height="50" class="pitch-marking" />
                    
                    <!-- Penalty Spots -->
                    <circle cx="16" cy="50" r="0.5" class="pitch-marking" fill="white" />
                    <circle cx="84" cy="50" r="0.5" class="pitch-marking" fill="white" />
                    
                    <!-- Penalty Arcs -->
                    <path d="M 21.15,41 A 9.15,9.15 0 0,1 21.15,59" class="pitch-marking" />
                    <path d="M 78.85,41 A 9.15,9.15 0 0,0 78.85,59" class="pitch-marking" />
                    
                    <!-- Goal Lines -->
                    <line x1="5" y1="36" x2="1" y2="36" class="pitch-marking" />
                    <line x1="5" y1="64" x2="1" y2="64" class="pitch-marking" />
                    <line x1="95" y1="36" x2="99" y2="36" class="pitch-marking" />
                    <line x1="95" y1="64" x2="99" y2="64" class="pitch-marking" />
                    <line x1="1" y1="36" x2="1" y2="64" class="pitch-marking" />
                    <line x1="99" y1="36" x2="99" y2="64" class="pitch-marking" />
                </svg>
                
                <!-- Player elements will be added dynamically -->
                {% for position in player_positions %}
                    <div class="player-item" data-player-id="{{ position.player.id }}" 
                         style="top: {{ position.y_coordinate }}%; left: {{ position.x_coordinate }}%;" 
                         data-x="{{ position.x_coordinate }}" data-y="{{ position.y_coordinate }}">
                        <div class="player-circle {% if position.is_starter %}starter{% else %}substitute{% endif %}">
                            <span class="player-jersey">{{ position.jersey_number|default:'' }}</span>
                            {% if position.position %}
                                <span class="player-position">{{ position.position.short_name }}</span>
                            {% endif %}
                        </div>
                        <div class="player-name">{{ position.player.first_name }}</div>
                        <span class="remove-player" title="Remove from lineup">×</span>
                    </div>
                {% endfor %}
            </div>
            
            <div class="mt-3 d-flex justify-content-between">
                <button id="save-positions" class="btn btn-primary">
                    <i class="fas fa-save"></i> Save Positions
                </button>
                
                <div class="btn-group">
                    <div class="dropdown">
                        <button class="btn btn-outline-secondary dropdown-toggle" type="button" id="formationDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="fas fa-th"></i> Apply Formation
                        </button>
                        <ul class="dropdown-menu" aria-labelledby="formationDropdown">
                            {% for formation in formations %}
                                <li><a class="dropdown-item formation-option" href="#" data-formation="{{ formation.formation_structure }}">
                                    {{ formation.name }} ({{ formation.formation_structure }})
                                </a></li>
                            {% endfor %}
                        </ul>
                    </div>
                    <button id="clear-positions" class="btn btn-outline-danger">
                        <i class="fas fa-trash"></i> Clear All
                    </button>
                </div>
            </div>
        </div>
        
        <div class="col-lg-4">
            <div class="controls-container">
                <!-- Player Editor Panel -->
                <div id="position-editor" class="mb-3" style="display: none;">
                    <h5>Edit Player</h5>
                    <form id="player-edit-form">
                        <input type="hidden" id="edit-player-id">
                        
                        <div class="mb-3">
                            <label for="edit-position" class="form-label">Position</label>
                            <select id="edit-position" class="form-select">
                                <option value="">-- No Position --</option>
                                {% for position in available_positions %}
                                    <option value="{{ position.id }}">{{ position.name }} ({{ position.short_name }})</option>
                                {% endfor %}
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label for="edit-jersey" class="form-label">Jersey Number</label>
                            <input type="number" class="form-control" id="edit-jersey" min="1" max="99">
                        </div>
                        
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="edit-starter" checked>
                            <label class="form-check-label" for="edit-starter">
                                Starting XI
                            </label>
                        </div>
                        
                        <div class="mb-3">
                            <label for="edit-notes" class="form-label">Notes</label>
                            <input type="text" class="form-control" id="edit-notes" maxlength="100">
                        </div>
                        
                        <div class="d-flex justify-content-between">
                            <button type="button" id="cancel-edit" class="btn btn-outline-secondary">Cancel</button>
                            <button type="submit" class="btn btn-primary">Apply Changes</button>
                        </div>
                    </form>
                </div>
                
                <!-- Available Players -->
                <div class="card mb-3">
                    <div class="card-header">
                        <h5 class="mb-0">Available Players</h5>
                    </div>
                    <div class="card-body p-2">
                        <div class="player-bank" id="player-bank">
                            {% for player in available_players %}
                                <div class="player-item" data-player-id="{{ player.id }}">
                                    <div class="player-circle starter">
                                        <span class="player-jersey"></span>
                                    </div>
                                    <div class="player-name">{{ player.first_name }}</div>
                                    <span class="remove-player" title="Remove from lineup">×</span>
                                </div>
                            {% endfor %}
                            
                            {% if not available_players %}
                                <div class="text-center text-muted p-3">
                                    All active players are in the lineup
                                </div>
                            {% endif %}
                        </div>
                    </div>
                </div>
                
                <!-- Position Legend -->
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Positions</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            {% for position in available_positions %}
                                <div class="col-6 mb-2">
                                    <span class="badge" style="background-color: #0066cc;">{{ position.short_name }}</span>
                                    {{ position.name }}
                                </div>
                            {% endfor %}
                        </div>
                        
                        {% if not available_positions %}
                            <div class="text-center text-muted">
                                No positions defined yet
                            </div>
                            {% if is_admin %}
                                <div class="mt-2">
                                    <a href="{% url 'position-list' %}" class="btn btn-sm btn-outline-primary">Manage Positions</a>
                                </div>
                            {% endif %}
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize draggable elements
    let activeDragElement = null;
    let selectedElement = null;
    let initialX = 0;
    let initialY = 0;
    let currentX = 0;
    let currentY = 0;
    let xOffset = 0;
    let yOffset = 0;
    let positionsChanged = false; // Track if positions have changed
    
    const playerItems = document.querySelectorAll('.player-item');
    const playerBank = document.getElementById('player-bank');
    const pitchContainer = document.getElementById('pitch-container');
    
    // Player editor elements
    const positionEditor = document.getElementById('position-editor');
    const editPlayerIdInput = document.getElementById('edit-player-id');
    const editPositionSelect = document.getElementById('edit-position');
    const editJerseyInput = document.getElementById('edit-jersey');
    const editStarterCheckbox = document.getElementById('edit-starter');
    const editNotesInput = document.getElementById('edit-notes');
    const playerEditForm = document.getElementById('player-edit-form');
    const cancelEditButton = document.getElementById('cancel-edit');
    
    // Buttons and controls
    const savePositionsButton = document.getElementById('save-positions');
    const clearPositionsButton = document.getElementById('clear-positions');
    const formationOptions = document.querySelectorAll('.formation-option');
    
    // Lineup data
    const lineupId = {{ lineup.id }};
    const lineupData = {
        playerPositions: []
    };
    
    // Make all player items draggable
    playerItems.forEach(item => {
        initDraggable(item);
        
        // Add click event for editing
        item.addEventListener('dblclick', function(event) {
            if (event.target.classList.contains('remove-player')) {
                // Don't open editor if the remove button was clicked
                return;
            }
            openPlayerEditor(item);
        });
        
        // Add remove button functionality
        const removeButton = item.querySelector('.remove-player');
        if (removeButton) {
            removeButton.addEventListener('click', function() {
                removePlayerFromLineup(item);
            });
        }
    });
    
    // Handle player edit form submission
    playerEditForm.addEventListener('submit', function(event) {
        event.preventDefault();
        applyPlayerEdits();
    });
    
    // Cancel button in player editor
    cancelEditButton.addEventListener('click', function() {
        positionEditor.style.display = 'none';
        selectedElement = null;
    });
    
    // Save positions button
    savePositionsButton.addEventListener('click', function() {
        saveLineupPositions();
    });
    
    // Clear positions button
    clearPositionsButton.addEventListener('click', function() {
        if (confirm('Are you sure you want to clear all players from the pitch? This cannot be undone.')) {
            clearAllPositions();
        }
    });
    
    // Formation options
    formationOptions.forEach(option => {
        option.addEventListener('click', function(e) {
            e.preventDefault();
            const formation = this.getAttribute('data-formation');
            applyFormation(formation);
        });
    });
    
    // Initialize draggable functionality for an element
    function initDraggable(element) {
        element.addEventListener('mousedown', dragStart, false);
        element.addEventListener('mouseup', dragEnd, false);
        element.addEventListener('touchstart', dragStart, false);
        element.addEventListener('touchend', dragEnd, false);
        element.addEventListener('touchcancel', dragEnd, false);
    }
    
    // Start dragging an element
    function dragStart(e) {
        e.preventDefault();
        
        if (e.type === 'touchstart') {
            initialX = e.touches[0].clientX;
            initialY = e.touches[0].clientY;
        } else {
            initialX = e.clientX;
            initialY = e.clientY;
        }
        
        activeDragElement = e.currentTarget;
        
        // If the element is in the player bank, we need to clone it
        if (activeDragElement.parentNode === playerBank) {
            activeDragElement = clonePlayerToField(activeDragElement);
        }
        
        // Get the current position of the draggable element
        const style = window.getComputedStyle(activeDragElement);
        if (activeDragElement.style.top) {
            xOffset = parseFloat(activeDragElement.style.left) || 0;
            yOffset = parseFloat(activeDragElement.style.top) || 0;
        } else {
            const rect = activeDragElement.getBoundingClientRect();
            const pitchRect = pitchContainer.getBoundingClientRect();
            
            xOffset = ((rect.left + rect.width/2) - pitchRect.left) / pitchRect.width * 100;
            yOffset = ((rect.top + rect.height/2) - pitchRect.top) / pitchRect.height * 100;
            
            activeDragElement.style.left = `${xOffset}%`;
            activeDragElement.style.top = `${yOffset}%`;
        }
        
        // Add the dragging class
        activeDragElement.classList.add('dragging');
        
        document.addEventListener('mousemove', drag, false);
        document.addEventListener('touchmove', drag, false);
    }
    
    // Handle drag movement
    function drag(e) {
        if (activeDragElement === null) return;
        
        e.preventDefault();
        
        if (e.type === 'touchmove') {
            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;
        } else {
            currentX = e.clientX;
            currentY = e.clientY;
        }
        
        // Calculate the new position as a percentage of the pitch size
        const pitchRect = pitchContainer.getBoundingClientRect();
        const newX = ((currentX - pitchRect.left) / pitchRect.width) * 100;
        const newY = ((currentY - pitchRect.top) / pitchRect.height) * 100;
        
        // Constrain to pitch boundaries (with a small margin)
        const boundedX = Math.max(0, Math.min(100, newX));
        const boundedY = Math.max(0, Math.min(100, newY));
        
        // Format to 2 decimal places to avoid excessive precision
        const formattedX = parseFloat(boundedX.toFixed(2));
        const formattedY = parseFloat(boundedY.toFixed(2));
        
        // Update the position with both style and data attributes
        activeDragElement.style.left = `${formattedX}%`;
        activeDragElement.style.top = `${formattedY}%`;
        
        // Set the data attributes explicitly with the same values
        activeDragElement.setAttribute('data-x', formattedX);
        activeDragElement.setAttribute('data-y', formattedY);
        
        // Log for debugging (uncomment if needed)
        // console.log(`Dragging to: (${formattedX}%, ${formattedY}%), Player ID: ${activeDragElement.getAttribute('data-player-id')}`);
    }
    
    // End dragging
    function dragEnd(e) {
        if (activeDragElement === null) return;
        
        // Remove the dragging class
        activeDragElement.classList.remove('dragging');
        
        // Get the final position from style (most accurate after drag)
        let finalX = parseFloat(activeDragElement.style.left);
        let finalY = parseFloat(activeDragElement.style.top);
        
        // Handle percentage signs if present
        if (isNaN(finalX) || isNaN(finalY)) {
            finalX = parseFloat(activeDragElement.style.left.replace('%', ''));
            finalY = parseFloat(activeDragElement.style.top.replace('%', ''));
        }
        
        // Format to 2 decimal places to avoid excessive precision
        finalX = parseFloat(finalX.toFixed(2));
        finalY = parseFloat(finalY.toFixed(2));
        
        // Ensure coordinates are within valid range
        finalX = Math.max(0, Math.min(100, finalX));
        finalY = Math.max(0, Math.min(100, finalY));
        
        // Make sure these are valid numbers and update data attributes and style consistently
        if (!isNaN(finalX) && !isNaN(finalY)) {
            // Update both data attributes and style properties with the same values
            activeDragElement.setAttribute('data-x', finalX);
            activeDragElement.setAttribute('data-y', finalY);
            activeDragElement.style.left = `${finalX}%`;
            activeDragElement.style.top = `${finalY}%`;
            
            console.log(`Drag ended at: (${finalX}%, ${finalY}%), Player ID: ${activeDragElement.getAttribute('data-player-id')}`);
            
            // Mark positions as changed
            positionsChanged = true;
        }
        
        // Ensure the element is properly within the pitch
        positionWithinPitch(activeDragElement);
        
        // Remove the event listeners
        document.removeEventListener('mousemove', drag, false);
        document.removeEventListener('touchmove', drag, false);
        
        // Reset active drag element
        activeDragElement = null;
    }
    
    // Ensure the element stays within the pitch boundaries
    function positionWithinPitch(element) {
        const x = parseFloat(element.getAttribute('data-x'));
        const y = parseFloat(element.getAttribute('data-y'));
        
        // If data attributes aren't set, get from style
        let finalX = x;
        let finalY = y;
        
        if (isNaN(finalX) || isNaN(finalY)) {
            finalX = parseFloat(element.style.left.replace('%', '')) || 50;
            finalY = parseFloat(element.style.top.replace('%', '')) || 50;
        }
        
        // Format to 2 decimal places to avoid excessive precision
        finalX = parseFloat(finalX.toFixed(2));
        finalY = parseFloat(finalY.toFixed(2));
        
        // Constrain to pitch boundaries
        finalX = Math.max(0, Math.min(100, finalX));
        finalY = Math.max(0, Math.min(100, finalY));
        
        // Update both style and data attributes with the exact same value
        element.style.left = `${finalX}%`;
        element.style.top = `${finalY}%`;
        element.setAttribute('data-x', finalX);
        element.setAttribute('data-y', finalY);
    }
    
    // Clone a player from the bank to the pitch
    function clonePlayerToField(playerElement) {
        // Create a clone of the player
        const clone = playerElement.cloneNode(true);
        
        // Add it to the pitch container
        pitchContainer.appendChild(clone);
        
        // Set initial position near the center of the pitch
        clone.style.left = '50%';
        clone.style.top = '50%';
        clone.setAttribute('data-x', 50);
        clone.setAttribute('data-y', 50);
        
        // Add all event listeners to the clone
        initDraggable(clone);
        
        // Add double-click for editing
        clone.addEventListener('dblclick', function(event) {
            if (event.target.classList.contains('remove-player')) {
                return;
            }
            openPlayerEditor(clone);
        });
        
        // Add remove button functionality
        const removeButton = clone.querySelector('.remove-player');
        if (removeButton) {
            removeButton.addEventListener('click', function() {
                removePlayerFromLineup(clone);
            });
        }
        
        // Hide the original player in the bank (as it's now on the field)
        playerElement.style.display = 'none';
        
        return clone;
    }
    
    // Open the player editor with a selected player's data
    function openPlayerEditor(playerElement) {
        selectedElement = playerElement;
        const playerId = playerElement.getAttribute('data-player-id');
        
        // Get current values (if any)
        const playerCircle = playerElement.querySelector('.player-circle');
        const playerPosition = playerElement.querySelector('.player-position');
        const jerseyNumber = playerElement.querySelector('.player-jersey').textContent;
        
        // Set up the form
        editPlayerIdInput.value = playerId;
        editJerseyInput.value = jerseyNumber || '';
        editStarterCheckbox.checked = playerCircle.classList.contains('starter');
        
        // Find the position ID if it exists
        if (playerPosition) {
            const positionText = playerPosition.textContent;
            
            // Try to find the position in the dropdown by short_name
            const options = editPositionSelect.options;
            for (let i = 0; i < options.length; i++) {
                if (options[i].text.includes(`(${positionText})`)) {
                    editPositionSelect.selectedIndex = i;
                    break;
                }
            }
        } else {
            editPositionSelect.selectedIndex = 0;
        }
        
        // Get notes from data attribute if set
        editNotesInput.value = playerElement.getAttribute('data-notes') || '';
        
        // Show the editor
        positionEditor.style.display = 'block';
        
        // Scroll to the editor
        positionEditor.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    
    // Apply edits to the selected player
    function applyPlayerEdits() {
        if (!selectedElement) return;
        
        // Get values from the form
        const positionId = editPositionSelect.value;
        const positionText = editPositionSelect.options[editPositionSelect.selectedIndex].text;
        const jerseyNumber = editJerseyInput.value;
        const isStarter = editStarterCheckbox.checked;
        const notes = editNotesInput.value;
        
        // Update the player element
        const playerCircle = selectedElement.querySelector('.player-circle');
        const jerseyElement = selectedElement.querySelector('.player-jersey');
        
        // Update jersey number
        jerseyElement.textContent = jerseyNumber;
        
        // Update starter status
        if (isStarter) {
            playerCircle.classList.remove('substitute');
            playerCircle.classList.add('starter');
        } else {
            playerCircle.classList.remove('starter');
            playerCircle.classList.add('substitute');
        }
        
        // Update position
        let positionElement = selectedElement.querySelector('.player-position');
        if (positionId) {
            // Extract the short name from the option text (format: "Name (Short)")
            const shortName = positionText.match(/\(([^)]+)\)/)[1];
            
            if (!positionElement) {
                positionElement = document.createElement('span');
                positionElement.className = 'player-position';
                playerCircle.appendChild(positionElement);
            }
            positionElement.textContent = shortName;
            selectedElement.setAttribute('data-position-id', positionId);
        } else if (positionElement) {
            positionElement.remove();
            selectedElement.removeAttribute('data-position-id');
        }
        
        // Store notes as data attribute
        if (notes) {
            selectedElement.setAttribute('data-notes', notes);
        } else {
            selectedElement.removeAttribute('data-notes');
        }
        
        // Hide the editor
        positionEditor.style.display = 'none';
        selectedElement = null;
    }
    
    // Remove a player from the lineup
    function removePlayerFromLineup(playerElement) {
        const playerId = playerElement.getAttribute('data-player-id');
        
        // Remove the player element from the pitch
        playerElement.remove();
        
        // Unhide the player in the bank if it exists
        const bankPlayer = document.querySelector(`#player-bank .player-item[data-player-id="${playerId}"]`);
        if (bankPlayer) {
            bankPlayer.style.display = 'inline-block';
        }
        
        // If the editor is open for this player, close it
        if (selectedElement && selectedElement.getAttribute('data-player-id') === playerId) {
            positionEditor.style.display = 'none';
            selectedElement = null;
        }
    }
    
    // Save all player positions
    function saveLineupPositions() {
        // Collect all player positions from the pitch
        const positions = [];
        const playersOnPitch = pitchContainer.querySelectorAll('.player-item');
        
        console.log(`Saving positions for ${playersOnPitch.length} players on the pitch`);
        
        // First, ensure all players' positions are within pitch bounds
        playersOnPitch.forEach(player => {
            positionWithinPitch(player);
        });
        
        // Now collect the data
        playersOnPitch.forEach(player => {
            const playerId = player.getAttribute('data-player-id');
            const positionId = player.getAttribute('data-position-id') || null;
            
            // Try to get coordinates from data attributes first (should be most reliable now)
            let x = parseFloat(player.getAttribute('data-x'));
            let y = parseFloat(player.getAttribute('data-y'));
            
            // If data attributes aren't set for some reason, fall back to style
            if (isNaN(x) || isNaN(y)) {
                const styleLeft = player.style.left;
                const styleTop = player.style.top;
                
                x = styleLeft ? parseFloat(styleLeft.replace('%', '')) : 0;
                y = styleTop ? parseFloat(styleTop.replace('%', '')) : 0;
                
                // Update the data attributes to maintain consistency
                player.setAttribute('data-x', x);
                player.setAttribute('data-y', y);
                
                console.log(`Updated from style: ${x}, ${y} for player ${playerId}`);
            } else {
                console.log(`Using data attributes: ${x}, ${y} for player ${playerId}`);
            }
            
            // Check if style values match data attributes
            const currentStyleLeft = parseFloat(player.style.left.replace('%', ''));
            const currentStyleTop = parseFloat(player.style.top.replace('%', ''));
            
            if (Math.abs(currentStyleLeft - x) > 0.1 || Math.abs(currentStyleTop - y) > 0.1) {
                console.log(`Style and data don't match for player ${playerId}!`);
                console.log(`Style: (${currentStyleLeft}, ${currentStyleTop}), Data: (${x}, ${y})`);
                // Force synchronization of style with data attributes
                player.style.left = `${x}%`;
                player.style.top = `${y}%`;
            }
            
            // Ensure coordinates are within valid range
            x = Math.max(0, Math.min(100, x));
            y = Math.max(0, Math.min(100, y));
            
            const playerCircle = player.querySelector('.player-circle');
            const isStarter = playerCircle.classList.contains('starter');
            const jerseyNumber = player.querySelector('.player-jersey').textContent;
            const notes = player.getAttribute('data-notes') || '';
            
            positions.push({
                player_id: playerId,
                position_id: positionId,
                x: x,
                y: y,
                is_starter: isStarter,
                jersey_number: jerseyNumber !== '' ? parseInt(jerseyNumber) : null,
                notes: notes
            });
        });
        
        // Send the data to the server
        // Get CSRF token from our hidden form
        const csrfToken = document.querySelector('#csrf-form [name=csrfmiddlewaretoken]').value;
        
        fetch(`{% url 'save-lineup-positions' lineup.id %}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                positions: positions
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Show success message
                alert('Lineup positions saved successfully!');
            } else {
                // Show error message
                alert('Error saving lineup: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error saving lineup:', error);
            alert('Error saving lineup. Please try again.');
        });
    }
    
    // Clear all players from the pitch
    function clearAllPositions() {
        // Get all players on the pitch
        const playersOnPitch = pitchContainer.querySelectorAll('.player-item');
        
        // Remove each player and unhide them in the bank
        playersOnPitch.forEach(player => {
            const playerId = player.getAttribute('data-player-id');
            
            // Remove from pitch
            player.remove();
            
            // Unhide in bank
            const bankPlayer = document.querySelector(`#player-bank .player-item[data-player-id="${playerId}"]`);
            if (bankPlayer) {
                bankPlayer.style.display = 'inline-block';
            }
        });
        
        // Close editor if open
        if (selectedElement) {
            positionEditor.style.display = 'none';
            selectedElement = null;
        }
    }
    
    // Apply a formation to the players on the pitch
    function applyFormation(formationString) {
        // Parse the formation string (e.g., "4-4-2")
        const layers = formationString.split('-').map(num => parseInt(num));
        
        // Get all players on the pitch
        const playersOnPitch = Array.from(pitchContainer.querySelectorAll('.player-item'));
        
        // Skip if not enough players
        if (playersOnPitch.length < layers.reduce((a, b) => a + b, 1)) { // +1 for goalkeeper
            alert('Not enough players on the pitch for this formation!');
            return;
        }
        
        // Mark positions as changed since we're rearranging players
        positionsChanged = true;
        
        // Sort players by position type (goalkeepers first, then defenders, etc.)
        playersOnPitch.sort((a, b) => {
            const posA = a.querySelector('.player-position');
            const posB = b.querySelector('.player-position');
            
            if (!posA && !posB) return 0;
            if (!posA) return 1;
            if (!posB) return -1;
            
            const posTextA = posA.textContent;
            const posTextB = posB.textContent;
            
            if (posTextA.includes('GK')) return -1;
            if (posTextB.includes('GK')) return 1;
            
            if (posTextA.includes('DEF') && !posTextB.includes('DEF')) return -1;
            if (posTextB.includes('DEF') && !posTextA.includes('DEF')) return 1;
            
            if (posTextA.includes('MID') && posTextB.includes('FWD')) return -1;
            if (posTextB.includes('MID') && posTextA.includes('FWD')) return 1;
            
            return 0;
        });
        
        // Position for goalkeeper
        const goalkeeper = playersOnPitch.shift(); // Take first player for GK
        if (goalkeeper) {
            goalkeeper.style.left = '8%';
            goalkeeper.style.top = '50%';
            goalkeeper.setAttribute('data-x', 8);
            goalkeeper.setAttribute('data-y', 50);
        }
        
        // Calculate positions for other players
        let currentPlayerIndex = 0;
        
        // For each layer of the formation
        for (let i = 0; i < layers.length; i++) {
            const numPlayers = layers[i];
            const xPosition = 25 + (i * 20); // Distribute along x-axis (25%, 45%, 65%, 85%)
            
            // Calculate y-positions for this layer
            for (let j = 0; j < numPlayers && currentPlayerIndex < playersOnPitch.length; j++) {
                const player = playersOnPitch[currentPlayerIndex];
                const yGap = 100 / (numPlayers + 1);
                const yPosition = yGap * (j + 1);
                
                player.style.left = `${xPosition}%`;
                player.style.top = `${yPosition}%`;
                player.setAttribute('data-x', xPosition);
                player.setAttribute('data-y', yPosition);
                
                currentPlayerIndex++;
            }
        }
        
        // Place any remaining players along the sideline
        for (let i = currentPlayerIndex; i < playersOnPitch.length; i++) {
            const player = playersOnPitch[i];
            const yPosition = 5 + (i - currentPlayerIndex) * 10;
            
            player.style.left = '1%';
            player.style.top = `${yPosition}%`;
            player.setAttribute('data-x', 1);
            player.setAttribute('data-y', yPosition);
            
            // Mark as substitute
            const playerCircle = player.querySelector('.player-circle');
            playerCircle.classList.remove('starter');
            playerCircle.classList.add('substitute');
        }
    }
    
    // Function to auto-save the positions
    function autoSavePositions() {
        try {
            // Check if we should save
            if (!positionsChanged) {
                console.log('No changes to save');
                return; // No need to save if nothing changed
            }
            
            // Check if we're still on the lineup builder page
            if (!pitchContainer || !document.body.contains(pitchContainer)) {
                console.log('Pitch container not found, cancelling auto-save');
                return;
            }
            
            // Find the CSRF token from our hidden form
            const csrfTokenElement = document.querySelector('#csrf-form [name=csrfmiddlewaretoken]');
            if (!csrfTokenElement) {
                console.error('CSRF token not found, cannot save positions');
                return;
            }
            
            const csrfToken = csrfTokenElement.value;
            const playersOnPitch = pitchContainer.querySelectorAll('.player-item');
            
            if (!playersOnPitch || playersOnPitch.length === 0) {
                console.log('No players on pitch to save');
                return;
            }
            
            const positions = [];
            
            // Process player positions
            playersOnPitch.forEach(player => {
                try {
                    // Make sure player stays within bounds
                    positionWithinPitch(player);
                    
                    const playerId = player.getAttribute('data-player-id');
                    if (!playerId) {
                        console.warn('Player without ID found, skipping');
                        return;
                    }
                    
                    const positionId = player.getAttribute('data-position-id') || null;
                    
                    // Get coordinates with fallbacks
                    let x = parseFloat(player.getAttribute('data-x'));
                    let y = parseFloat(player.getAttribute('data-y'));
                    
                    // Fallback to style values if data attributes aren't set
                    if (isNaN(x) || isNaN(y)) {
                        const styleLeft = player.style.left;
                        const styleTop = player.style.top;
                        
                        x = styleLeft ? parseFloat(styleLeft.replace('%', '')) : 50;
                        y = styleTop ? parseFloat(styleTop.replace('%', '')) : 50;
                        
                        // Update the data attributes for future use
                        player.setAttribute('data-x', x);
                        player.setAttribute('data-y', y);
                    }
                    
                    // Ensure valid values
                    x = Math.max(0, Math.min(100, x));
                    y = Math.max(0, Math.min(100, y));
                    
                    const playerCircle = player.querySelector('.player-circle');
                    if (!playerCircle) {
                        console.warn(`Player circle not found for player ${playerId}, assuming starter`);
                    }
                    
                    const isStarter = playerCircle ? playerCircle.classList.contains('starter') : true;
                    
                    const jerseyElement = player.querySelector('.player-jersey');
                    const jerseyNumber = jerseyElement ? jerseyElement.textContent : '';
                    const notes = player.getAttribute('data-notes') || '';
                    
                    positions.push({
                        player_id: playerId,
                        position_id: positionId,
                        x: x,
                        y: y,
                        is_starter: isStarter,
                        jersey_number: jerseyNumber !== '' ? parseInt(jerseyNumber) : null,
                        notes: notes
                    });
                } catch (playerError) {
                    console.error('Error processing player for auto-save:', playerError);
                }
            });
            
            if (positions.length === 0) {
                console.log('No valid positions to save');
                return;
            }
            
            console.log(`Auto-saving ${positions.length} player positions...`);
            
            // Use fetch for auto-save
            fetch(`/lineups/${lineupId}/save-positions/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    positions: positions
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('Auto-save successful!');
                    positionsChanged = false; // Reset changed flag
                } else {
                    console.error('Auto-save failed:', data.message);
                }
            })
            .catch(error => {
                console.error('Auto-save error:', error);
            });
        } catch (e) {
            console.error('Auto-save function error:', e);
        }
    }
    
    // Set up auto-save every 30 seconds if changes are made
    const autoSaveInterval = setInterval(autoSavePositions, 30000);
    
    // Also save when links are clicked
    document.querySelectorAll('a').forEach(link => {
        link.addEventListener('click', function(e) {
            if (positionsChanged) {
                // Don't prevent navigation, but trigger save first
                console.log('Link clicked, saving positions before navigation...');
                autoSavePositions();
            }
        });
    });
    
    // Add beforeunload event to warn before leaving the page with unsaved changes
    window.addEventListener('beforeunload', function(e) {
        // Only prompt and save if positions have been changed
        if (positionsChanged) {
            // Attempt to save one more time
            console.log('Page unloading, attempting final save...');
            
            try {
                // Check if the necessary elements exist
                if (!pitchContainer || !document.body.contains(pitchContainer)) {
                    console.log('Cannot perform final save: pitch container not found');
                    return;
                }
                
                // Find the CSRF token from our hidden form
                const csrfTokenElement = document.querySelector('#csrf-form [name=csrfmiddlewaretoken]');
                if (!csrfTokenElement) {
                    console.error('Cannot perform final save: CSRF token not found');
                    return;
                }
                
                // Use synchronous XMLHttpRequest (deprecated but necessary for beforeunload)
                const xhr = new XMLHttpRequest();
                const csrfToken = csrfTokenElement.value;
                const playersOnPitch = pitchContainer.querySelectorAll('.player-item');
                
                if (!playersOnPitch || playersOnPitch.length === 0) {
                    console.log('No players to save on unload');
                    return;
                }
                
                const positions = [];
                
                // Process player positions synchronously (safely)
                playersOnPitch.forEach(player => {
                    try {
                        // Ensure player stays within pitch bounds
                        positionWithinPitch(player);
                        
                        // Get player attributes with safety checks
                        const playerId = player.getAttribute('data-player-id');
                        if (!playerId) {
                            console.warn('Player without ID found during final save, skipping');
                            return;
                        }
                        
                        const positionId = player.getAttribute('data-position-id') || null;
                        
                        // Get coordinates with fallbacks
                        let x = parseFloat(player.getAttribute('data-x'));
                        let y = parseFloat(player.getAttribute('data-y'));
                        
                        // Fallback to style values if data attributes aren't set
                        if (isNaN(x) || isNaN(y)) {
                            const styleLeft = player.style.left;
                            const styleTop = player.style.top;
                            
                            x = styleLeft ? parseFloat(styleLeft.replace('%', '')) : 50;
                            y = styleTop ? parseFloat(styleTop.replace('%', '')) : 50;
                        }
                        
                        // Ensure valid values
                        x = Math.max(0, Math.min(100, x));
                        y = Math.max(0, Math.min(100, y));
                        
                        // Get player status
                        const playerCircle = player.querySelector('.player-circle');
                        const isStarter = playerCircle ? playerCircle.classList.contains('starter') : true;
                        
                        const jerseyElement = player.querySelector('.player-jersey');
                        const jerseyNumber = jerseyElement ? jerseyElement.textContent : '';
                        const notes = player.getAttribute('data-notes') || '';
                        
                        positions.push({
                            player_id: playerId,
                            position_id: positionId,
                            x: x,
                            y: y,
                            is_starter: isStarter,
                            jersey_number: jerseyNumber !== '' ? parseInt(jerseyNumber) : null,
                            notes: notes
                        });
                    } catch (playerError) {
                        console.error('Error processing player during final save:', playerError);
                    }
                });
                
                if (positions.length === 0) {
                    console.log('No valid positions for final save');
                    return;
                }
                
                console.log(`Final save with ${positions.length} player positions`);
                
                // Send the data synchronously
                xhr.open('POST', `/lineups/${lineupId}/save-positions/`, false); // false = synchronous
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.setRequestHeader('X-CSRFToken', csrfToken);
                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                xhr.send(JSON.stringify({ positions: positions }));
                
                console.log('Final save status:', xhr.status);
                
                if (xhr.status >= 200 && xhr.status < 300) {
                    console.log('Final save successful!');
                } else {
                    console.error('Final save failed with status:', xhr.status);
                }
            } catch (e) {
                console.error('Final save error:', e);
            }
            
            // Classic way to show a confirmation dialog when leaving
            const confirmationMessage = 'You have unsaved changes. We tried to save them automatically, but do you want to leave now?';
            (e || window.event).returnValue = confirmationMessage;
            return confirmationMessage;
        }
    });
    
    // Also mark positions as changed when a player is added to the field or when edits are applied
    const originalClonePlayerToField = clonePlayerToField;
    clonePlayerToField = function(playerElement) {
        positionsChanged = true;
        return originalClonePlayerToField(playerElement);
    };
    
    const originalApplyPlayerEdits = applyPlayerEdits;
    applyPlayerEdits = function() {
        positionsChanged = true;
        return originalApplyPlayerEdits();
    };
    
    const originalRemovePlayerFromLineup = removePlayerFromLineup;
    removePlayerFromLineup = function(playerElement) {
        positionsChanged = true;
        return originalRemovePlayerFromLineup(playerElement);
    };
    
    // Update the original saveLineupPositions function to reset the positionsChanged flag
    const originalSaveLineupPositions = saveLineupPositions;
    saveLineupPositions = function() {
        try {
            // Check if we're still on the lineup builder page
            if (!pitchContainer || !document.body.contains(pitchContainer)) {
                console.error('Pitch container not found, cannot save positions');
                alert('Error: Unable to locate the pitch. Please refresh the page and try again.');
                return;
            }
            
            // Collect all player positions from the pitch
            const positions = [];
            const playersOnPitch = pitchContainer.querySelectorAll('.player-item');
            
            if (!playersOnPitch || playersOnPitch.length === 0) {
                alert('No players have been placed on the pitch. Please add players before saving.');
                return;
            }
            
            console.log(`Saving positions for ${playersOnPitch.length} players on the pitch`);
            
            // First, ensure all players' positions are within pitch bounds
            playersOnPitch.forEach(player => {
                positionWithinPitch(player);
            });
            
            // Now collect the data with better error handling
            playersOnPitch.forEach(player => {
                try {
                    const playerId = player.getAttribute('data-player-id');
                    if (!playerId) {
                        console.warn('Player without ID found during manual save, skipping');
                        return;
                    }
                    
                    const positionId = player.getAttribute('data-position-id') || null;
                    
                    // Try to get coordinates from data attributes first
                    let x = parseFloat(player.getAttribute('data-x'));
                    let y = parseFloat(player.getAttribute('data-y'));
                    
                    // If data attributes aren't set for some reason, fall back to style
                    if (isNaN(x) || isNaN(y)) {
                        const styleLeft = player.style.left;
                        const styleTop = player.style.top;
                        
                        x = styleLeft ? parseFloat(styleLeft.replace('%', '')) : 50;
                        y = styleTop ? parseFloat(styleTop.replace('%', '')) : 50;
                        
                        // Update the data attributes to maintain consistency
                        player.setAttribute('data-x', x);
                        player.setAttribute('data-y', y);
                        
                        console.log(`Updated coordinates from style: ${x}, ${y} for player ${playerId}`);
                    }
                    
                    // Ensure coordinates are within valid range
                    x = Math.max(0, Math.min(100, x));
                    y = Math.max(0, Math.min(100, y));
                    
                    const playerCircle = player.querySelector('.player-circle');
                    if (!playerCircle) {
                        console.warn(`Player circle not found for player ${playerId}, assuming starter`);
                    }
                    
                    const isStarter = playerCircle ? playerCircle.classList.contains('starter') : true;
                    
                    const jerseyElement = player.querySelector('.player-jersey');
                    const jerseyNumber = jerseyElement ? jerseyElement.textContent : '';
                    const notes = player.getAttribute('data-notes') || '';
                    
                    positions.push({
                        player_id: playerId,
                        position_id: positionId,
                        x: x,
                        y: y,
                        is_starter: isStarter,
                        jersey_number: jerseyNumber !== '' ? parseInt(jerseyNumber) : null,
                        notes: notes
                    });
                } catch (playerError) {
                    console.error('Error processing player for manual save:', playerError);
                }
            });
            
            if (positions.length === 0) {
                alert('No valid positions to save. Please add players to the pitch first.');
                return;
            }
            
            // Find the CSRF token from our hidden form
            const csrfTokenElement = document.querySelector('#csrf-form [name=csrfmiddlewaretoken]');
            if (!csrfTokenElement) {
                console.error('CSRF token not found, cannot save positions');
                alert('Error: CSRF token not found. Please refresh the page and try again.');
                return;
            }
            
            const csrfToken = csrfTokenElement.value;
            
            // Show saving indicator to user
            const saveButton = document.querySelector('#save-button');
            const originalButtonText = saveButton ? saveButton.textContent : 'Save';
            if (saveButton) {
                saveButton.textContent = 'Saving...';
                saveButton.disabled = true;
            }
            
            // Send the data to the server
            fetch(`/lineups/${lineupId}/save-positions/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    positions: positions
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server returned status ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    // Show success message
                    alert('Lineup positions saved successfully!');
                    // Reset the changed flag after successful save
                    positionsChanged = false;
                    console.log('Manual save successful:', data);
                } else {
                    // Show error message
                    alert('Error saving lineup: ' + (data.message || 'Unknown error'));
                    console.error('Manual save failed:', data);
                }
            })
            .catch(error => {
                console.error('Error saving lineup:', error);
                alert('Error saving lineup. Please try again.');
            })
            .finally(() => {
                // Restore button state
                if (saveButton) {
                    saveButton.textContent = originalButtonText;
                    saveButton.disabled = false;
                }
            });
        } catch (e) {
            console.error('Error in save function:', e);
            alert('An unexpected error occurred while saving. Please try again.');
        }
    };
});
</script>
{% endblock %}